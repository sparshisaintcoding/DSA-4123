<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unit1</title>
    <link rel="stylesheet" href="programs.css">
</head>
<body>
    <div class="d" id="d1">
        <h2>1. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of the node structure
        struct Node {
            int data;
            struct Node* next;
        };
        
        // Head of the linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
            newNode->next = head;
            head = newNode;
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(int value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (position == 0) {
                newNode->next = head;
                head = newNode;
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
            newNode->next = NULL;
        
            if (isEmpty()) {
                head = newNode;
            } else {
                struct Node* current = head;
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = newNode;
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
            struct Node* temp = head;
            head = head->next;
            free(temp);
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
            if (head->next == NULL) {
                free(head);
                head = NULL;
                return;
            }
        
            struct Node* current = head;
            while (current->next->next != NULL) {
                current = current->next;
            }
            free(current->next);
            current->next = NULL;
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL || current->next == NULL) {
                printf("Position out of bounds.\n");
            } else {
                struct Node* temp = current->next;
                current->next = temp->next;
                free(temp);
            }
        }
        
        // Function to display the linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
            struct Node* current = head;
            while (current != NULL) {
                printf("%d -> ", current->data);
                current = current->next;
            }
            printf("NULL\n");
        }
        
        // Function to search for a value in the linked list
        void search(int value) {
            struct Node* current = head;
            int position = 0;
            while (current != NULL) {
                if (current->data == value) {
                    printf("Value %d found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            }
            printf("Value %d not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, value, position;
        
            while (1) {
                printf("\nLinked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        scanf("%d", &value);
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        scanf("%d %d", &value, &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        scanf("%d", &value);
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        scanf("%d", &value);
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: 5
    
    Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    5 -> NULL
        
        </pre>
    </div>


    <div class="d" id="d2">
        <h2>2. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of the node structure
        struct Node {
            int data;
            struct Node* next;
        };
        
        // Head of the circular linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (isEmpty()) {
                head = newNode;
                newNode->next = head; // Point to itself
            } else {
                struct Node* temp = head;
                while (temp->next != head) {
                    temp = temp->next;
                }
                temp->next = newNode; // Last node points to new node
                newNode->next = head; // New node points to head
                head = newNode; // Update head
            }
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(int value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            if (isEmpty()) {
                printf("List is empty. Cannot insert at position %d.\n", position);
                free(newNode);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current->next != head; i++) {
                current = current->next;
            }
        
            if (current->next == head && i < position - 1) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (isEmpty()) {
                head = newNode;
                newNode->next = head; // Point to itself
            } else {
                struct Node* temp = head;
                while (temp->next != head) {
                    temp = temp->next;
                }
                temp->next = newNode; // Last node points to new node
                newNode->next = head; // New node points to head
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* temp = head;
        
            if (head->next == head) { // Only one node
                free(head);
                head = NULL;
            } else {
                struct Node* last = head;
                while (last->next != head) {
                    last = last->next;
                }
                head = head->next; // Move head to the next node
                last->next = head; // Update last node's next
                free(temp);
            }
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* current = head;
        
            if (current->next == head) { // Only one node
                free(head);
                head = NULL;
                return;
            }
        
            struct Node* previous = NULL;
            while (current->next != head) {
                previous = current;
                current = current->next;
            }
        
            previous->next = head; // Last node's next points to head
            free(current);
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            struct Node* previous = NULL;
            for (int i = 0; i < position && current->next != head; i++) {
                previous = current;
                current = current->next;
            }
        
            if (current == head && i < position) {
                printf("Position out of bounds.\n");
            } else {
                previous->next = current->next; // Bypass the current node
                free(current);
            }
        }
        
        // Function to display the circular linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            do {
                printf("%d -> ", current->data);
                current = current->next;
            } while (current != head);
            printf("(head)\n");
        }
        
        // Function to search for a value in the circular linked list
        void search(int value) {
            struct Node* current = head;
            int position = 0;
        
            if (isEmpty()) {
                printf("List is empty. Cannot search.\n");
                return;
            }
        
            do {
                if (current->data == value) {
                    printf("Value %d found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            } while (current != head);
        
            printf("Value %d not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, value, position;
        
            while (1) {
                printf("\nCircular Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        scanf("%d", &value);
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        scanf("%d %d", &value, &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        scanf("%d", &value);
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        scanf("%d", &value);
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
        


    <b id="b">Output:</b>
    Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: 5
    
    Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
        
        </pre>
    </div>


    <div class="d" id="d3">
        <h2>3. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of the node structure
        struct Node {
            int data;
            struct Node* next;
            struct Node* prev;
        };
        
        // Head of the doubly linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
            newNode->next = head;
            newNode->prev = NULL;
        
            if (head != NULL) {
                head->prev = newNode;
            }
            head = newNode;
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(int value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                newNode->prev = current;
        
                if (current->next != NULL) {
                    current->next->prev = newNode;
                }
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
            newNode->next = NULL;
        
            if (isEmpty()) {
                newNode->prev = NULL;
                head = newNode;
                return;
            }
        
            struct Node* current = head;
            while (current->next != NULL) {
                current = current->next;
            }
        
            current->next = newNode;
            newNode->prev = current;
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* temp = head;
            head = head->next;
        
            if (head != NULL) {
                head->prev = NULL;
            }
            free(temp);
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* current = head;
        
            if (current->next == NULL) { // Only one node
                free(current);
                head = NULL;
                return;
            }
        
            while (current->next != NULL) {
                current = current->next;
            }
        
            current->prev->next = NULL;
            free(current);
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
            } else {
                if (current->prev != NULL) {
                    current->prev->next = current->next;
                }
                if (current->next != NULL) {
                    current->next->prev = current->prev;
                }
                free(current);
            }
        }
        
        // Function to display the doubly linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            while (current != NULL) {
                printf("%d <-> ", current->data);
                current = current->next;
            }
            printf("NULL\n");
        }
        
        // Function to search for a value in the doubly linked list
        void search(int value) {
            struct Node* current = head;
            int position = 0;
        
            while (current != NULL) {
                if (current->data == value) {
                    printf("Value %d found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            }
        
            printf("Value %d not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, value, position;
        
            while (1) {
                printf("\nDoubly Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        scanf("%d", &value);
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        scanf("%d %d", &value, &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        scanf("%d", &value);
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        scanf("%d", &value);
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Doubly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: 10
    
    Doubly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 3
    Enter value to insert at end: 20
    
    Doubly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    10 <-> 20 <-> NULL
        
        </pre>
    </div>


    <div class="d" id="d4">
        <h2>4. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of the node structure
        struct Node {
            int data;
            struct Node* next;
            struct Node* prev;
        };
        
        // Head of the doubly circular linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (isEmpty()) {
                head = newNode;
                newNode->next = head;
                newNode->prev = head;
            } else {
                struct Node* tail = head->prev; // Get the last node
                newNode->next = head; // New node points to head
                newNode->prev = tail; // New node's prev points to the tail
                tail->next = newNode; // Old tail points to new node
                head->prev = newNode; // Head's prev points to new node
                head = newNode; // Update head
            }
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(int value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            if (isEmpty()) {
                printf("List is empty. Cannot insert at position %d.\n", position);
                free(newNode);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current->next != head; i++) {
                current = current->next;
            }
        
            if (current->next == head && i < position - 1) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                newNode->prev = current;
                current->next->prev = newNode;
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
        
            if (isEmpty()) {
                head = newNode;
                newNode->next = head;
                newNode->prev = head;
            } else {
                struct Node* tail = head->prev; // Get the last node
                tail->next = newNode; // Old tail points to new node
                newNode->prev = tail; // New node's prev points to old tail
                newNode->next = head; // New node points to head
                head->prev = newNode; // Head's prev points to new node
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* temp = head;
            if (head->next == head) { // Only one node
                free(head);
                head = NULL;
            } else {
                struct Node* tail = head->prev; // Get the last node
                head = head->next; // Move head to the next node
                tail->next = head; // Update last node's next
                head->prev = tail; // Update new head's prev
                free(temp);
            }
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* tail = head->prev; // Get the last node
        
            if (tail == head) { // Only one node
                free(tail);
                head = NULL;
            } else {
                struct Node* newTail = tail->prev; // Get the new tail
                newTail->next = head; // Update new tail's next to head
                head->prev = newTail; // Update head's prev
                free(tail);
            }
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position && current->next != head; i++) {
                current = current->next;
            }
        
            if (current == head && i < position) {
                printf("Position out of bounds.\n");
            } else {
                current->prev->next = current->next; // Bypass the current node
                current->next->prev = current->prev; // Bypass the current node
                free(current);
            }
        }
        
        // Function to display the doubly circular linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            do {
                printf("%d <-> ", current->data);
                current = current->next;
            } while (current != head);
            printf("(head)\n");
        }
        
        // Function to search for a value in the doubly circular linked list
        void search(int value) {
            struct Node* current = head;
            int position = 0;
        
            if (isEmpty()) {
                printf("List is empty. Cannot search.\n");
                return;
            }
        
            do {
                if (current->data == value) {
                    printf("Value %d found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            } while (current != head);
        
            printf("Value %d not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, value, position;
        
            while (1) {
                printf("\nDoubly Circular Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        scanf("%d", &value);
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        scanf("%d %d", &value, &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        scanf("%d", &value);
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        scanf("%d", &value);
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }


    <b id="b">Output:</b>
    Doubly Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: 10
    
    Doubly Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 3
    Enter value to insert at end: 20
    
    Doubly Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    10 <-> 20 <-> (head)    
        </pre>
    </div>
    
    <div class="d" id="d5">
        <h2>5. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_STRING_LENGTH 100
        
        // Definition of the node structure
        struct Node {
            char data[MAX_STRING_LENGTH];
            struct Node* next;
        };
        
        // Head of the singly linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            newNode->next = head;
            head = newNode;
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(char* value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
        
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            newNode->next = NULL;
        
            if (isEmpty()) {
                head = newNode;
            } else {
                struct Node* current = head;
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = newNode;
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* temp = head;
            head = head->next;
            free(temp);
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (head->next == NULL) { // Only one node
                free(head);
                head = NULL;
                return;
            }
        
            struct Node* current = head;
            while (current->next->next != NULL) {
                current = current->next;
            }
        
            free(current->next);
            current->next = NULL;
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL || current->next == NULL) {
                printf("Position out of bounds.\n");
            } else {
                struct Node* temp = current->next;
                current->next = temp->next;
                free(temp);
            }
        }
        
        // Function to display the singly linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            while (current != NULL) {
                printf("%s -> ", current->data);
                current = current->next;
            }
            printf("NULL\n");
        }
        
        // Function to search for a string in the singly linked list
        void search(char* value) {
            struct Node* current = head;
            int position = 0;
        
            while (current != NULL) {
                if (strcmp(current->data, value) == 0) {
                    printf("Value '%s' found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            }
        
            printf("Value '%s' not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, position;
            char value[MAX_STRING_LENGTH];
        
            while (1) {
                printf("\nSingly Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // To consume the newline character left by scanf
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        printf("Position: ");
                        scanf("%d", &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
        
    

    <b id="b">Output:</b>
    Singly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: Hello
    
    Singly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 3
    Enter value to insert at end: World
    
    Singly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    Hello -> World -> NULL
        
        </pre>
    </div>

    <div class="d" id="d6">
        <h2>6. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_STRING_LENGTH 100
        
        // Definition of the node structure
        struct Node {
            char data[MAX_STRING_LENGTH];
            struct Node* next;
        };
        
        // Head of the singly linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            newNode->next = head;
            head = newNode;
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(char* value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
        
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            newNode->next = NULL;
        
            if (isEmpty()) {
                head = newNode;
            } else {
                struct Node* current = head;
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = newNode;
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* temp = head;
            head = head->next;
            free(temp);
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (head->next == NULL) { // Only one node
                free(head);
                head = NULL;
                return;
            }
        
            struct Node* current = head;
            while (current->next->next != NULL) {
                current = current->next;
            }
        
            free(current->next);
            current->next = NULL;
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL || current->next == NULL) {
                printf("Position out of bounds.\n");
            } else {
                struct Node* temp = current->next;
                current->next = temp->next;
                free(temp);
            }
        }
        
        // Function to display the singly linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            while (current != NULL) {
                printf("%s -> ", current->data);
                current = current->next;
            }
            printf("NULL\n");
        }
        
        // Function to search for a string in the singly linked list
        void search(char* value) {
            struct Node* current = head;
            int position = 0;
        
            while (current != NULL) {
                if (strcmp(current->data, value) == 0) {
                    printf("Value '%s' found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            }
        
            printf("Value '%s' not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, position;
            char value[MAX_STRING_LENGTH];
        
            while (1) {
                printf("\nSingly Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // To consume the newline character left by scanf
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        printf("Position: ");
                        scanf("%d", &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Singly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: Hello
    
    Singly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 3
    Enter value to insert at end: World
    
    Singly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    Hello -> World -> NULL
        
        </pre>
    </div>

    <div class="d" id="d7">
        <h2>7. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_STRING_LENGTH 100
        
        // Definition of the node structure
        struct Node {
            char data[MAX_STRING_LENGTH];
            struct Node* next;
            struct Node* prev;
        };
        
        // Head of the doubly linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            newNode->next = head;
            newNode->prev = NULL;
        
            if (isEmpty()) {
                head = newNode;
            } else {
                head->prev = newNode;
                head = newNode;
            }
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(char* value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
        
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                newNode->prev = current;
                if (current->next != NULL) {
                    current->next->prev = newNode;
                }
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            newNode->next = NULL;
        
            if (isEmpty()) {
                newNode->prev = NULL;
                head = newNode;
            } else {
                struct Node* current = head;
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = newNode;
                newNode->prev = current;
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* temp = head;
            head = head->next;
        
            if (head != NULL) {
                head->prev = NULL;
            }
            free(temp);
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            struct Node* current = head;
            if (current->next == NULL) { // Only one node
                free(head);
                head = NULL;
                return;
            }
        
            while (current->next != NULL) {
                current = current->next;
            }
        
            current->prev->next = NULL; // Update second last node's next
            free(current);
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position && current != NULL; i++) {
                current = current->next;
            }
        
            if (current == NULL) {
                printf("Position out of bounds.\n");
            } else {
                if (current->prev != NULL) {
                    current->prev->next = current->next;
                }
                if (current->next != NULL) {
                    current->next->prev = current->prev;
                }
                free(current);
            }
        }
        
        // Function to display the doubly linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            while (current != NULL) {
                printf("%s <-> ", current->data);
                current = current->next;
            }
            printf("NULL\n");
        }
        
        // Function to search for a string in the doubly linked list
        void search(char* value) {
            struct Node* current = head;
        
            if (isEmpty()) {
                printf("List is empty. Cannot search.\n");
                return;
            }
        
            int position = 0;
            while (current != NULL) {
                if (strcmp(current->data, value) == 0) {
                    printf("Value '%s' found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            }
        
            printf("Value '%s' not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, position;
            char value[MAX_STRING_LENGTH];
        
            while (1) {
                printf("\nDoubly Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // To consume the newline character left by scanf
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        printf("Position: ");
                        scanf("%d", &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Doubly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 1
    Enter value to insert at beginning: Hello
    
    
    
    Doubly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 3
    Enter value to insert at end: World
    
    Doubly Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    Hello <-> World <-> NULL    
        </pre>
    </div>

    <div class="d" id="d8">
        <h2>8. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_STRING_LENGTH 100
        
        // Definition of the node structure
        struct Node {
            char data[MAX_STRING_LENGTH];
            struct Node* next;
            struct Node* prev;
        };
        
        // Head of the doubly circular linked list
        struct Node* head = NULL;
        
        // Function to check if the list is empty
        int isEmpty() {
            return head == NULL;
        }
        
        // Function to insert a node at the beginning
        void insertAtBeginning(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            
            if (isEmpty()) {
                head = newNode;
                head->next = head;
                head->prev = head;
            } else {
                struct Node* tail = head->prev;
                newNode->next = head;
                newNode->prev = tail;
                head->prev = newNode;
                tail->next = newNode;
                head = newNode;
            }
        }
        
        // Function to insert a node at a specific position
        void insertAtPosition(char* value, int position) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            
            if (position == 0) {
                insertAtBeginning(value);
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position - 1 && current != head; i++) {
                current = current->next;
            }
        
            if (current == head && position != 0) {
                printf("Position out of bounds.\n");
                free(newNode);
            } else {
                newNode->next = current->next;
                newNode->prev = current;
                current->next->prev = newNode;
                current->next = newNode;
            }
        }
        
        // Function to insert a node at the end
        void insertAtEnd(char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, MAX_STRING_LENGTH);
            
            if (isEmpty()) {
                head = newNode;
                head->next = head;
                head->prev = head;
            } else {
                struct Node* tail = head->prev;
                newNode->next = head;
                newNode->prev = tail;
                tail->next = newNode;
                head->prev = newNode;
            }
        }
        
        // Function to delete a node at the beginning
        void deleteAtBeginning() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (head->next == head) { // Only one node
                free(head);
                head = NULL;
            } else {
                struct Node* tail = head->prev;
                struct Node* temp = head;
                head = head->next;
                tail->next = head;
                head->prev = tail;
                free(temp);
            }
        }
        
        // Function to delete a node at the end
        void deleteAtEnd() {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (head->next == head) { // Only one node
                free(head);
                head = NULL;
            } else {
                struct Node* tail = head->prev;
                tail->prev->next = head;
                head->prev = tail->prev;
                free(tail);
            }
        }
        
        // Function to delete a node at a specific position
        void deleteAtPosition(int position) {
            if (isEmpty()) {
                printf("List is empty. Cannot delete.\n");
                return;
            }
        
            if (position == 0) {
                deleteAtBeginning();
                return;
            }
        
            struct Node* current = head;
            for (int i = 0; i < position && current != head; i++) {
                current = current->next;
            }
        
            if (current == head) {
                printf("Position out of bounds.\n");
            } else {
                current->prev->next = current->next;
                current->next->prev = current->prev;
                free(current);
            }
        }
        
        // Function to display the doubly circular linked list
        void display() {
            if (isEmpty()) {
                printf("List is empty.\n");
                return;
            }
        
            struct Node* current = head;
            do {
                printf("%s <-> ", current->data);
                current = current->next;
            } while (current != head);
            printf("(head)\n");
        }
        
        // Function to search for a string in the doubly circular linked list
        void search(char* value) {
            struct Node* current = head;
        
            if (isEmpty()) {
                printf("List is empty. Cannot search.\n");
                return;
            }
        
            int position = 0;
            do {
                if (strcmp(current->data, value) == 0) {
                    printf("Value '%s' found at position %d.\n", value, position);
                    return;
                }
                current = current->next;
                position++;
            } while (current != head);
        
            printf("Value '%s' not found in the list.\n", value);
        }
        
        // Main function
        int main() {
            int choice, position;
            char value[MAX_STRING_LENGTH];
        
            while (1) {
                printf("\nDoubly Circular Linked List Operations:\n");
                printf("1. Insert at Beginning\n");
                printf("2. Insert at Position\n");
                printf("3. Insert at End\n");
                printf("4. Delete at Beginning\n");
                printf("5. Delete at End\n");
                printf("6. Delete at Position\n");
                printf("7. Display\n");
                printf("8. Search\n");
                printf("9. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // To consume the newline character left by scanf
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at beginning: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtBeginning(value);
                        break;
                    case 2:
                        printf("Enter value to insert and position: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        printf("Position: ");
                        scanf("%d", &position);
                        insertAtPosition(value, position);
                        break;
                    case 3:
                        printf("Enter value to insert at end: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        insertAtEnd(value);
                        break;
                    case 4:
                        deleteAtBeginning();
                        break;
                    case 5:
                        deleteAtEnd();
                        break;
                    case 6:
                        printf("Enter position to delete: ");
                        scanf("%d", &position);
                        deleteAtPosition(position);
                        break;
                    case 7:
                        display();
                        break;
                    case 8:
                        printf("Enter value to search: ");
                        fgets(value, MAX_STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = '\0'; // Remove newline character
                        search(value);
                        break;
                    case 9:
                        exit(0);
                    default:
                        printf("Invalid choice. Please try again.\n");
                }
            }
        
            return 0;
        }
                

    <b id="b">Output:</b>
    Doubly Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 
    
    1
    Enter value to insert at beginning: Hello
    
    Doubly Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 3
    Enter value to insert at end: World
    
    Doubly Circular Linked List Operations:
    1. Insert at Beginning
    2. Insert at Position
    3. Insert at End
    4. Delete at Beginning
    5. Delete at End
    6. Delete at Position
    7. Display
    8. Search
    9. Exit
    Enter your choice: 7
    Hello <-> World <-> (head)    
        </pre>
    </div>

    <div class="d" id="d9">
        <h2>9. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Define the node structure for a polynomial term
        struct Term {
            int coeff;  // Coefficient
            int exp;    // Exponent
            struct Term* next;
        };
        
        // Function to create a new term
        struct Term* createTerm(int coeff, int exp) {
            struct Term* newTerm = (struct Term*)malloc(sizeof(struct Term));
            newTerm->coeff = coeff;
            newTerm->exp = exp;
            newTerm->next = NULL;
            return newTerm;
        }
        
        // Function to insert a term into the polynomial (sorted by exponent)
        void insertTerm(struct Term** poly, int coeff, int exp) {
            struct Term* newTerm = createTerm(coeff, exp);
            if (*poly == NULL || (*poly)->exp < exp) {
                newTerm->next = *poly;
                *poly = newTerm;
            } else {
                struct Term* current = *poly;
                while (current->next != NULL && current->next->exp > exp) {
                    current = current->next;
                }
                if (current->exp == exp) {
                    current->coeff += coeff; // Combine like terms
                    free(newTerm); // Free the new term since it will not be used
                } else {
                    newTerm->next = current->next;
                    current->next = newTerm;
                }
            }
        }
        
        // Function to read a polynomial from the user
        struct Term* readPolynomial() {
            struct Term* poly = NULL;
            int numTerms, coeff, exp;
        
            printf("Enter the number of terms in the polynomial: ");
            scanf("%d", &numTerms);
        
            for (int i = 0; i < numTerms; i++) {
                printf("Enter coefficient and exponent of term %d: ", i + 1);
                scanf("%d %d", &coeff, &exp);
                insertTerm(&poly, coeff, exp);
            }
        
            return poly;
        }
        
        // Function to add two polynomials
        struct Term* addPolynomials(struct Term* poly1, struct Term* poly2) {
            struct Term* result = NULL;
        
            while (poly1 != NULL || poly2 != NULL) {
                if (poly1 == NULL) {
                    insertTerm(&result, poly2->coeff, poly2->exp);
                    poly2 = poly2->next;
                } else if (poly2 == NULL) {
                    insertTerm(&result, poly1->coeff, poly1->exp);
                    poly1 = poly1->next;
                } else if (poly1->exp > poly2->exp) {
                    insertTerm(&result, poly1->coeff, poly1->exp);
                    poly1 = poly1->next;
                } else if (poly1->exp < poly2->exp) {
                    insertTerm(&result, poly2->coeff, poly2->exp);
                    poly2 = poly2->next;
                } else {
                    insertTerm(&result, poly1->coeff + poly2->coeff, poly1->exp);
                    poly1 = poly1->next;
                    poly2 = poly2->next;
                }
            }
        
            return result;
        }
        
        // Function to display the polynomial
        void displayPolynomial(struct Term* poly) {
            if (poly == NULL) {
                printf("0\n");
                return;
            }
        
            struct Term* current = poly;
            while (current != NULL) {
                printf("%d x^%d", current->coeff, current->exp);
                current = current->next;
                if (current != NULL) {
                    printf(" + ");
                }
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            printf("Enter the first polynomial:\n");
            struct Term* poly1 = readPolynomial();
            
            printf("Enter the second polynomial:\n");
            struct Term* poly2 = readPolynomial();
        
            struct Term* result = addPolynomials(poly1, poly2);
        
            printf("Resulting polynomial after addition:\n");
            displayPolynomial(result);
        
            // Free allocated memory (not implemented in this example for brevity)
        
            return 0;
        }
        
        

    <b id="b">Output:</b>
    Enter the first polynomial:
    Enter the number of terms in the polynomial: 2
    Enter coefficient and exponent of term 1: 3 2
    Enter coefficient and exponent of term 2: 4 0
    
    Enter the second polynomial:
    Enter the number of terms in the polynomial: 2
    Enter coefficient and exponent of term 1: 2 1
    Enter coefficient and exponent of term 2: 5 0
    
    Resulting polynomial after addition:
    3 x^2 + 2 x^1 + 9 x^0
        
        </pre>
    </div>

    <div class="d" id="d10">
        <h2>10. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Define the node structure for a polynomial term
        struct Term {
            int coeff;  // Coefficient
            int exp;    // Exponent
            struct Term* next;
        };
        
        // Function to create a new term
        struct Term* createTerm(int coeff, int exp) {
            struct Term* newTerm = (struct Term*)malloc(sizeof(struct Term));
            newTerm->coeff = coeff;
            newTerm->exp = exp;
            newTerm->next = NULL;
            return newTerm;
        }
        
        // Function to insert a term into the polynomial (sorted by exponent)
        void insertTerm(struct Term** poly, int coeff, int exp) {
            struct Term* newTerm = createTerm(coeff, exp);
            if (*poly == NULL || (*poly)->exp < exp) {
                newTerm->next = *poly;
                *poly = newTerm;
            } else {
                struct Term* current = *poly;
                while (current->next != NULL && current->next->exp > exp) {
                    current = current->next;
                }
                if (current->exp == exp) {
                    current->coeff += coeff; // Combine like terms
                    free(newTerm); // Free the new term since it will not be used
                } else {
                    newTerm->next = current->next;
                    current->next = newTerm;
                }
            }
        }
        
        // Function to read a polynomial from the user
        struct Term* readPolynomial() {
            struct Term* poly = NULL;
            int numTerms, coeff, exp;
        
            printf("Enter the number of terms in the polynomial: ");
            scanf("%d", &numTerms);
        
            for (int i = 0; i < numTerms; i++) {
                printf("Enter coefficient and exponent of term %d: ", i + 1);
                scanf("%d %d", &coeff, &exp);
                insertTerm(&poly, coeff, exp);
            }
        
            return poly;
        }
        
        // Function to subtract two polynomials
        struct Term* subtractPolynomials(struct Term* poly1, struct Term* poly2) {
            struct Term* result = NULL;
        
            while (poly1 != NULL || poly2 != NULL) {
                int coeff, exp;
        
                if (poly1 == NULL) {
                    coeff = -poly2->coeff;
                    exp = poly2->exp;
                    poly2 = poly2->next;
                } else if (poly2 == NULL) {
                    coeff = poly1->coeff;
                    exp = poly1->exp;
                    poly1 = poly1->next;
                } else if (poly1->exp > poly2->exp) {
                    coeff = poly1->coeff;
                    exp = poly1->exp;
                    poly1 = poly1->next;
                } else if (poly1->exp < poly2->exp) {
                    coeff = -poly2->coeff;
                    exp = poly2->exp;
                    poly2 = poly2->next;
                } else {
                    coeff = poly1->coeff - poly2->coeff;
                    exp = poly1->exp;
                    poly1 = poly1->next;
                    poly2 = poly2->next;
                }
        
                if (coeff != 0) {
                    insertTerm(&result, coeff, exp);
                }
            }
        
            return result;
        }
        
        // Function to display the polynomial
        void displayPolynomial(struct Term* poly) {
            if (poly == NULL) {
                printf("0\n");
                return;
            }
        
            struct Term* current = poly;
            while (current != NULL) {
                printf("%d x^%d", current->coeff, current->exp);
                current = current->next;
                if (current != NULL) {
                    printf(" + ");
                }
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            printf("Enter the first polynomial:\n");
            struct Term* poly1 = readPolynomial();
            
            printf("Enter the second polynomial:\n");
            struct Term* poly2 = readPolynomial();
        
            struct Term* result = subtractPolynomials(poly1, poly2);
        
            printf("Resulting polynomial after subtraction:\n");
            displayPolynomial(result);
        
            // Free allocated memory (not implemented in this example for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Enter the first polynomial:
    Enter the number of terms in the polynomial: 2
    Enter coefficient and exponent of term 1: 5 2
    Enter coefficient and exponent of term 2: 3 0
    
    Enter the second polynomial:
    Enter the number of terms in the polynomial: 2
    Enter coefficient and exponent of term 1: 2 1
    Enter coefficient and exponent of term 2: 4 0
    
    Resulting polynomial after subtraction:
    5 x^2 - 2 x^1 - 1 x^0
        
        </pre>
    </div>


    <div class="d" id="d11">
        <h2>11. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Define the node structure for a polynomial term
        struct Term {
            int coeff;  // Coefficient
            int exp;    // Exponent
            struct Term* next;
        };
        
        // Function to create a new term
        struct Term* createTerm(int coeff, int exp) {
            struct Term* newTerm = (struct Term*)malloc(sizeof(struct Term));
            newTerm->coeff = coeff;
            newTerm->exp = exp;
            newTerm->next = NULL;
            return newTerm;
        }
        
        // Function to insert a term into the polynomial (sorted by exponent)
        void insertTerm(struct Term** poly, int coeff, int exp) {
            struct Term* newTerm = createTerm(coeff, exp);
            if (*poly == NULL || (*poly)->exp < exp) {
                newTerm->next = *poly;
                *poly = newTerm;
            } else {
                struct Term* current = *poly;
                while (current->next != NULL && current->next->exp > exp) {
                    current = current->next;
                }
                if (current->exp == exp) {
                    current->coeff += coeff; // Combine like terms
                    free(newTerm); // Free the new term since it will not be used
                } else {
                    newTerm->next = current->next;
                    current->next = newTerm;
                }
            }
        }
        
        // Function to read a polynomial from the user
        struct Term* readPolynomial() {
            struct Term* poly = NULL;
            int numTerms, coeff, exp;
        
            printf("Enter the number of terms in the polynomial: ");
            scanf("%d", &numTerms);
        
            for (int i = 0; i < numTerms; i++) {
                printf("Enter coefficient and exponent of term %d: ", i + 1);
                scanf("%d %d", &coeff, &exp);
                insertTerm(&poly, coeff, exp);
            }
        
            return poly;
        }
        
        // Function to multiply two polynomials
        struct Term* multiplyPolynomials(struct Term* poly1, struct Term* poly2) {
            struct Term* result = NULL;
        
            for (struct Term* p1 = poly1; p1 != NULL; p1 = p1->next) {
                for (struct Term* p2 = poly2; p2 != NULL; p2 = p2->next) {
                    int coeff = p1->coeff * p2->coeff;
                    int exp = p1->exp + p2->exp;
                    insertTerm(&result, coeff, exp);
                }
            }
        
            return result;
        }
        
        // Function to display the polynomial
        void displayPolynomial(struct Term* poly) {
            if (poly == NULL) {
                printf("0\n");
                return;
            }
        
            struct Term* current = poly;
            while (current != NULL) {
                printf("%d x^%d", current->coeff, current->exp);
                current = current->next;
                if (current != NULL) {
                    printf(" + ");
                }
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            printf("Enter the first polynomial:\n");
            struct Term* poly1 = readPolynomial();
            
            printf("Enter the second polynomial:\n");
            struct Term* poly2 = readPolynomial();
        
            struct Term* result = multiplyPolynomials(poly1, poly2);
        
            printf("Resulting polynomial after multiplication:\n");
            displayPolynomial(result);
        
            // Free allocated memory (not implemented in this example for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Enter the first polynomial:
    Enter the number of terms in the polynomial: 2
    Enter coefficient and exponent of term 1: 3 2
    Enter coefficient and exponent of term 2: 4 0
    
    Enter the second polynomial:
    Enter the number of terms in the polynomial: 2
    Enter coefficient and exponent of term 1: 2 1
    Enter coefficient and exponent of term 2: 5 0
    
    Resulting polynomial after multiplication:
    6 x^3 + 12 x^2 + 20 x^0
        
        </pre>
    </div>


   
</body>
</html>
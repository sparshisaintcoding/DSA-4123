<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unit1</title>
    <link rel="stylesheet" href="programs.css">
</head>
<body>
    <div class="d" id="d1">
        <h2>1. CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to find the index of a value in the array
        int search(int arr[], int start, int end, int value) {
            for (int i = start; i <= end; i++) {
                if (arr[i] == value) {
                    return i;
                }
            }
            return -1; // Should not happen if input is valid
        }
        
        // Recursive function to construct the binary tree
        Node* buildTree(int preorder[], int inorder[], int inorderStart, int inorderEnd,
         int* preorderIndex)
         {
            // Base case
            if (inorderStart > inorderEnd) {
                return NULL;
            }
        
            // The current root value is at preorderIndex in preorder array
            int rootValue = preorder[*preorderIndex];
            Node* root = newNode(rootValue);
        
            // Increment preorderIndex for the next recursive call
            (*preorderIndex)++;
        
            // If this node has no children, return
            if (inorderStart == inorderEnd) {
                return root;
            }
        
            // Find the index of this root in inorder array
            int inorderIndex = search(inorder, inorderStart, inorderEnd, rootValue);
        
            // Using index in inorder array, construct left and right subtrees
            root->left = buildTree(preorder, inorder, inorderStart, inorderIndex - 1, preorderIndex);
            root->right = buildTree(preorder, inorder, inorderIndex + 1, inorderEnd, preorderIndex);
        
            return root;
        }
        
        // Function to print the tree in inorder (to verify construction)
        void inorderPrint(Node* node) {
            if (node == NULL) return;
            inorderPrint(node->left);
            printf("%d ", node->data);
            inorderPrint(node->right);
        }
        
        int main() {
            // Example preorder and inorder arrays
            int preorder[] = {1, 2, 4, 5, 3, 6, 7};
            int inorder[] = {4, 2, 5, 1, 6, 3, 7};
            int n = sizeof(preorder) / sizeof(preorder[0]);
            int preorderIndex = 0;
        
            // Build the tree
            Node* root = buildTree(preorder, inorder, 0, n - 1, &preorderIndex);
        
            // Print the inorder traversal of the constructed tree
            printf("Inorder traversal of the constructed tree: ");
            inorderPrint(root);
            printf("\n");
        
            // Freeing memory and cleanup would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Inorder traversal of the constructed tree: 4 2 5 1 6 3 7 

        </pre>
    </div>


    <div class="d" id="d2">
        <h2>2. BINARY TREE LEVEL ORDER TRAVERSAL.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Definition of a queue node
        typedef struct QueueNode {
            Node* treeNode;
            struct QueueNode* next;
        } QueueNode;
        
        // Queue structure
        typedef struct Queue {
            QueueNode* front;
            QueueNode* rear;
        } Queue;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to create a new queue node
        QueueNode* newQueueNode(Node* treeNode) {
            QueueNode* qNode = (QueueNode*)malloc(sizeof(QueueNode));
            qNode->treeNode = treeNode;
            qNode->next = NULL;
            return qNode;
        }
        
        // Function to create a queue
        Queue* createQueue() {
            Queue* q = (Queue*)malloc(sizeof(Queue));
            q->front = q->rear = NULL;
            return q;
        }
        
        // Function to enqueue a tree node
        void enqueue(Queue* q, Node* treeNode) {
            QueueNode* qNode = newQueueNode(treeNode);
            if (q->rear == NULL) {
                q->front = q->rear = qNode;
                return;
            }
            q->rear->next = qNode;
            q->rear = qNode;
        }
        
        // Function to dequeue a tree node
        Node* dequeue(Queue* q) {
            if (q->front == NULL) return NULL;
            QueueNode* temp = q->front;
            Node* treeNode = temp->treeNode;
            q->front = q->front->next;
            if (q->front == NULL) q->rear = NULL; // Queue is empty
            free(temp);
            return treeNode;
        }
        
        // Function for level order traversal
        void levelOrderTraversal(Node* root) {
            if (root == NULL) return;
        
            Queue* q = createQueue();
            enqueue(q, root);
        
            while (q->front != NULL) {
                Node* current = dequeue(q);
                printf("%d ", current->data);
        
                // Enqueue left child
                if (current->left != NULL) {
                    enqueue(q, current->left);
                }
                // Enqueue right child
                if (current->right != NULL) {
                    enqueue(q, current->right);
                }
            }
        
            // Clean up the queue
            free(q);
        }
        
        // Main function to demonstrate the level order traversal
        int main() {
            // Create a simple binary tree
            Node* root = newNode(1);
            root->left = newNode(2);
            root->right = newNode(3);
            root->left->left = newNode(4);
            root->left->right = newNode(5);
            root->right->left = newNode(6);
            root->right->right = newNode(7);
        
            printf("Level Order Traversal: ");
            levelOrderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
          1
        /   \
       2     3
      / \   / \
     4   5 6   7
 
    Level Order Traversal: 1 2 3 4 5 6 7 

        </pre>
    </div>


    <div class="d" id="d3">
        <h2>3.  PRINT LEFT VIEW OF BINARY TREE.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to print the left view of the binary tree
        void leftViewUtil(Node* root, int level, int* maxLevel) {
            // Base case
            if (root == NULL) return;
        
            // If this is the first node of its level
            if (*maxLevel < level) {
                printf("%d ", root->data);
                *maxLevel = level; // Update the maximum level reached
            }
        
            // Recursive calls for left and right subtrees
            leftViewUtil(root->left, level + 1, maxLevel);
            leftViewUtil(root->right, level + 1, maxLevel);
        }
        
        // Function to initiate left view traversal
        void leftView(Node* root) {
            int maxLevel = 0; // Variable to track the maximum level reached
            leftViewUtil(root, 1, &maxLevel); // Start from level 1
        }
        
        // Main function to demonstrate the left view
        int main() {
            // Create a sample binary tree
            Node* root = newNode(1);
            root->left = newNode(2);
            root->right = newNode(3);
            root->left->left = newNode(4);
            root->left->right = newNode(5);
            root->right->right = newNode(6);
            root->left->left->left = newNode(7);
        
            printf("Left View of the Binary Tree: ");
            leftView(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        
        

    <b id="b">Output:</b>
           1
         /   \
        2     3
       / \     \
      4   5     6
     /
    7

    Left View of the Binary Tree: 1 2 4 7 
 
        </pre>
    </div>


    <div class="d" id="d4">
        <h2>4. DISPLAY THE RIGHT VIEW OF BINARY TREE.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Utility function to print the right view of the binary tree
        void rightViewUtil(Node* root, int level, int* maxLevel) {
            // Base case
            if (root == NULL) return;
        
            // If this is the first node of its level from the right
            if (*maxLevel < level) {
                printf("%d ", root->data);
                *maxLevel = level; // Update the maximum level reached
            }
        
            // First recurse the right subtree, then the left subtree
            rightViewUtil(root->right, level + 1, maxLevel);
            rightViewUtil(root->left, level + 1, maxLevel);
        }
        
        // Function to initiate right view traversal
        void rightView(Node* root) {
            int maxLevel = 0; // Variable to track the maximum level reached
            rightViewUtil(root, 1, &maxLevel); // Start from level 1
        }
        
        // Main function to demonstrate the right view
        int main() {
            // Create a sample binary tree
            Node* root = newNode(1);
            root->left = newNode(2);
            root->right = newNode(3);
            root->left->left = newNode(4);
            root->left->right = newNode(5);
            root->right->right = newNode(6);
            root->left->left->left = newNode(7);
        
            printf("Right View of the Binary Tree: ");
            rightView(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
           1
         /   \
        2     3
       / \     \
      4   5     6
     /
    7

    Right View of the Binary Tree: 1 3 6 

        </pre>
    </div>
    
    <div class="d" id="d5">
        <h2>5. CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to find the index of a value in the array
        int search(int arr[], int start, int end, int value) {
            for (int i = start; i <= end; i++) {
                if (arr[i] == value) {
                    return i;
                }
            }
            return -1; // Should not happen if input is valid
        }
        
        // Recursive function to construct the binary tree
        Node* buildTree(int postorder[], int inorder[], int inorderStart, int inorderEnd,
         int* postorderIndex) {
            // Base case
            if (inorderStart > inorderEnd) {
                return NULL;
            }
        
            // The current root value is at postorderIndex in postorder array
            int rootValue = postorder[*postorderIndex];
            Node* root = newNode(rootValue);
        
            // Decrement postorderIndex for the next recursive call
            (*postorderIndex)--;
        
            // If this node has no children, return
            if (inorderStart == inorderEnd) {
                return root;
            }
        
            // Find the index of this root in inorder array
            int inorderIndex = search(inorder, inorderStart, inorderEnd, rootValue);
        
            // Using index in inorder array, construct right and left subtrees
            root->right = buildTree(postorder, inorder, inorderIndex + 1, inorderEnd, postorderIndex);
            root->left = buildTree(postorder, inorder, inorderStart, inorderIndex - 1, postorderIndex);
        
            return root;
        }
        
        // Function to print the tree in inorder (to verify construction)
        void inorderPrint(Node* node) {
            if (node == NULL) return;
            inorderPrint(node->left);
            printf("%d ", node->data);
            inorderPrint(node->right);
        }
        
        int main() {
            // Example postorder and inorder arrays
            int postorder[] = {4, 5, 2, 6, 7, 3, 1};
            int inorder[] = {4, 2, 5, 1, 6, 3, 7};
            int n = sizeof(postorder) / sizeof(postorder[0]);
            int postorderIndex = n - 1; // Start from the last index
        
            // Build the tree
            Node* root = buildTree(postorder, inorder, 0, n - 1, &postorderIndex);
        
            // Print the inorder traversal of the constructed tree
            printf("Inorder traversal of the constructed tree: ");
            inorderPrint(root);
            printf("\n");
        
            // Freeing memory and cleanup would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Inorder traversal of the constructed tree: 4 2 5 1 6 3 7 

        </pre>
    </div>

    <div class="d" id="d6">
        <h2>6.  FIND THE MAXIMUM DEPTH OF BINARY TREE.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to find the maximum depth of the binary tree
        int maxDepth(Node* root) {
            // Base case: if the tree is empty
            if (root == NULL) {
                return 0;
            }
        
            // Recursively find the depth of left and right subtrees
            int leftDepth = maxDepth(root->left);
            int rightDepth = maxDepth(root->right);
        
            // Return the maximum depth
            return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
        }
        
        // Main function to demonstrate the max depth calculation
        int main() {
            // Create a sample binary tree
            Node* root = newNode(1);
            root->left = newNode(2);
            root->right = newNode(3);
            root->left->left = newNode(4);
            root->left->right = newNode(5);
            root->right->right = newNode(6);
            root->left->left->left = newNode(7);
        
            // Calculate and print the maximum depth
            int depth = maxDepth(root);
            printf("Maximum depth of the binary tree: %d\n", depth);
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
           1
         /   \
        2     3
       / \     \
      4   5     6
     /
    7

    Maximum depth of the binary tree: 4

 
        </pre>
    </div>

    <div class="d" id="d7">
        <h2>7. CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        #define MAX_SIZE 100
        
        typedef struct BST {
            int* arr;    // Array to store BST elements
            int size;    // Current size of the BST
        } BST;
        
        // Function to create a new BST
        BST* createBST() {
            BST* bst = (BST*)malloc(sizeof(BST));
            bst->arr = (int*)malloc(MAX_SIZE * sizeof(int));
            bst->size = 0;
            return bst;
        }
        
        // Helper function to insert a value into the BST
        void insert(BST* bst, int value) {
            if (bst->size >= MAX_SIZE) {
                printf("BST is full, cannot insert %d\n", value);
                return;
            }
            int i = 0;
            while (i < bst->size) {
                if (value < bst->arr[i]) {
                    i = 2 * i + 1; // Go to left child
                } else {
                    i = 2 * i + 2; // Go to right child
                }
                if (i >= MAX_SIZE) {
                    printf("Cannot insert %d, tree is too deep\n", value);
                    return;
                }
            }
            // Insert the value
            bst->arr[bst->size] = value;
            bst->size++;
        }
        
        // Helper function to search for a value in the BST
        int search(BST* bst, int value) {
            int i = 0;
            while (i < bst->size) {
                if (bst->arr[i] == value) {
                    return 1; // Found
                }
                if (value < bst->arr[i]) {
                    i = 2 * i + 1; // Go to left child
                } else {
                    i = 2 * i + 2; // Go to right child
                }
            }
            return 0; // Not found
        }
        
        // Helper function to find the minimum value in the BST
        int findMinimum(BST* bst) {
            if (bst->size == 0) {
                printf("BST is empty.\n");
                return -1; // Or some indication of no elements
            }
            int i = 0;
            while (2 * i + 1 < bst->size) {
                i = 2 * i + 1; // Go to left child
            }
            return bst->arr[i];
        }
        
        // Preorder traversal
        void preorder(BST* bst, int index) {
            if (index >= bst->size) return;
            printf("%d ", bst->arr[index]);
            preorder(bst, 2 * index + 1); // Left child
            preorder(bst, 2 * index + 2); // Right child
        }
        
        // Inorder traversal
        void inorder(BST* bst, int index) {
            if (index >= bst->size) return;
            inorder(bst, 2 * index + 1); // Left child
            printf("%d ", bst->arr[index]);
            inorder(bst, 2 * index + 2); // Right child
        }
        
        // Postorder traversal
        void postorder(BST* bst, int index) {
            if (index >= bst->size) return;
            postorder(bst, 2 * index + 1); // Left child
            postorder(bst, 2 * index + 2); // Right child
            printf("%d ", bst->arr[index]);
        }
        
        // Helper function to delete a value (not implemented)
        void delete(BST* bst, int value) {
            // Deletion in an array-based BST can be complex.
            // For simplicity, we won't implement deletion here.
            // You can remove the node, and then fill the gap with a value,
            // possibly rearranging the tree as needed.
            printf("Deletion not implemented.\n");
        }
        
        int main() {
            BST* bst = createBST();
            
            // Insert values into the BST
            insert(bst, 50);
            insert(bst, 30);
            insert(bst, 20);
            insert(bst, 40);
            insert(bst, 70);
            insert(bst, 60);
            insert(bst, 80);
        
            // Search for a value
            int valueToSearch = 40;
            printf("Searching for %d: %s\n", valueToSearch, 
            search(bst, valueToSearch) ? "Found" : "Not Found");
        
            // Find minimum value
            printf("Minimum value in BST: %d\n", findMinimum(bst));
        
            // Display traversals
            printf("Preorder traversal: ");
            preorder(bst, 0);
            printf("\n");
        
            printf("Inorder traversal: ");
            inorder(bst, 0);
            printf("\n");
        
            printf("Postorder traversal: ");
            postorder(bst, 0);
            printf("\n");
        
            // Deletion example (not implemented)
            delete(bst, 20); 
        
            // Free memory (not implemented for brevity)
            free(bst->arr);
            free(bst);
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Searching for 40: Found
    Minimum value in BST: 20
    Preorder traversal: 50 30 20 40 70 60 80 
    Inorder traversal: 20 30 40 50 60 70 80 
    Postorder traversal: 20 40 30 60 80 70 50 
    Deletion not implemented.
        
        </pre>
    </div>

    <div class="d" id="d8">
        <h2>8. CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new value into the BST
        Node* insert(Node* root, int value) {
            if (root == NULL) {
                return newNode(value);
            }
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else {
                root->right = insert(root->right, value);
            }
            return root;
        }
        
        // Function to search for a value in the BST
        Node* search(Node* root, int value) {
            if (root == NULL || root->data == value) {
                return root;
            }
            if (value < root->data) {
                return search(root->left, value);
            }
            return search(root->right, value);
        }
        
        // Function to find the minimum value in the BST
        Node* findMinimum(Node* root) {
            while (root && root->left != NULL) {
                root = root->left;
            }
            return root;
        }
        
        // Function to delete a value from the BST
        Node* delete(Node* root, int value) {
            if (root == NULL) {
                return root;
            }
            if (value < root->data) {
                root->left = delete(root->left, value);
            } else if (value > root->data) {
                root->right = delete(root->right, value);
            } else {
                // Node with only one child or no child
                if (root->left == NULL) {
                    Node* temp = root->right;
                    free(root);
                    return temp;
                } else if (root->right == NULL) {
                    Node* temp = root->left;
                    free(root);
                    return temp;
                }
        
                // Node with two children: get the inorder successor (smallest in the right subtree)
                Node* temp = findMinimum(root->right);
                root->data = temp->data; // Copy the inorder successor's content to this node
                root->right = delete(root->right, temp->data); // Delete the inorder successor
            }
            return root;
        }
        
        // Preorder traversal
        void preorder(Node* root) {
            if (root == NULL) return;
            printf("%d ", root->data);
            preorder(root->left);
            preorder(root->right);
        }
        
        // Inorder traversal
        void inorder(Node* root) {
            if (root == NULL) return;
            inorder(root->left);
            printf("%d ", root->data);
            inorder(root->right);
        }
        
        // Postorder traversal
        void postorder(Node* root) {
            if (root == NULL) return;
            postorder(root->left);
            postorder(root->right);
            printf("%d ", root->data);
        }
        
        // Main function to demonstrate the BST operations
        int main() {
            Node* root = NULL;
        
            // Insert values into the BST
            root = insert(root, 50);
            root = insert(root, 30);
            root = insert(root, 20);
            root = insert(root, 40);
            root = insert(root, 70);
            root = insert(root, 60);
            root = insert(root, 80);
        
            // Search for a value
            int valueToSearch = 40;
            Node* foundNode = search(root, valueToSearch);
            printf("Searching for %d: %s\n", valueToSearch, foundNode ? "Found" : "Not Found");
        
            // Find minimum value
            Node* minNode = findMinimum(root);
            if (minNode) {
                printf("Minimum value in BST: %d\n", minNode->data);
            } else {
                printf("BST is empty.\n");
            }
        
            // Display traversals
            printf("Preorder traversal: ");
            preorder(root);
            printf("\n");
        
            printf("Inorder traversal: ");
            inorder(root);
            printf("\n");
        
            printf("Postorder traversal: ");
            postorder(root);
            printf("\n");
        
            // Delete a value
            printf("Deleting 20...\n");
            root = delete(root, 20);
            printf("Inorder traversal after deletion: ");
            inorder(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
          
                

    <b id="b">Output:</b>
    Searching for 40: Found
    Minimum value in BST: 20
    Preorder traversal: 50 30 20 40 70 60 80 
    Inorder traversal: 20 30 40 50 60 70 80 
    Postorder traversal: 20 40 30 60 80 70 50 
    Deleting 20...
    Inorder traversal after deletion: 30 40 50 60 70 80 
        
        </pre>
    </div>

    <div class="d" id="d9">
        <h2>9.  FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new value into the BST
        Node* insert(Node* root, int value) {
            if (root == NULL) {
                return newNode(value);
            }
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else {
                root->right = insert(root->right, value);
            }
            return root;
        }
        
        // Function to find the inorder predecessor of a given node
        Node* findInorderPredecessor(Node* root, Node* node) {
            if (node->left != NULL) {
                // The predecessor is the maximum value in the left subtree
                Node* current = node->left;
                while (current->right != NULL) {
                    current = current->right;
                }
                return current;
            }
        
            // If there is no left subtree, traverse the ancestors
            Node* predecessor = NULL;
            Node* current = root;
            while (current != NULL) {
                if (node->data < current->data) {
                    current = current->left;
                } else if (node->data > current->data) {
                    predecessor = current; // This might be the predecessor
                    current = current->right;
                } else {
                    break; // Node found
                }
            }
            return predecessor;
        }
        
        // Function to find the inorder successor of a given node
        Node* findInorderSuccessor(Node* root, Node* node) {
            if (node->right != NULL) {
                // The successor is the minimum value in the right subtree
                Node* current = node->right;
                while (current->left != NULL) {
                    current = current->left;
                }
                return current;
            }
        
            // If there is no right subtree, traverse the ancestors
            Node* successor = NULL;
            Node* current = root;
            while (current != NULL) {
                if (node->data < current->data) {
                    successor = current; // This might be the successor
                    current = current->left;
                } else if (node->data > current->data) {
                    current = current->right;
                } else {
                    break; // Node found
                }
            }
            return successor;
        }
        
        // Function to find a node in the BST
        Node* search(Node* root, int value) {
            if (root == NULL || root->data == value) {
                return root;
            }
            if (value < root->data) {
                return search(root->left, value);
            }
            return search(root->right, value);
        }
        
        // Main function to demonstrate finding predecessor and successor
        int main() {
            Node* root = NULL;
        
            // Insert values into the BST
            root = insert(root, 50);
            insert(root, 30);
            insert(root, 20);
            insert(root, 40);
            insert(root, 70);
            insert(root, 60);
            insert(root, 80);
        
            // Search for a node to find its predecessor and successor
            int valueToFind = 30;
            Node* node = search(root, valueToFind);
        
            if (node) {
                Node* predecessor = findInorderPredecessor(root, node);
                Node* successor = findInorderSuccessor(root, node);
        
                printf("Node: %d\n", node->data);
                printf("Inorder Predecessor: %s\n", predecessor ? predecessor->data : -1);
                printf("Inorder Successor: %s\n", successor ? successor->data : -1);
            } else {
                printf("Node %d not found in the BST.\n", valueToFind);
            }
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        
      
        

    <b id="b">Output:</b>
    Node: 30
    Inorder Predecessor: 20
    Inorder Successor: 40
        
        </pre>
    </div>

    <div class="d" id="d10">
        <h2>10. CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < stdbool.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new value into the BST
        Node* insert(Node* root, int value) {
            if (root == NULL) {
                return newNode(value);
            }
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else {
                root->right = insert(root->right, value);
            }
            return root;
        }
        
        // Helper function to check for dead ends
        bool hasDeadEnd(Node* root, int min, int max) {
            if (root == NULL) {
                return false; // No dead end at this node
            }
            
            // If the current node is a dead end
            if (root->left == NULL && 
            root->right == NULL && 
            min == root->data - 1 && 
            max == root->data + 1) {
                return true;
            }
            
            // Recursively check the left and right subtrees with updated bounds
            return hasDeadEnd(root->left, min, root->data) || hasDeadEnd(root->right, root->data, max);
        }
        
        // Function to check if the BST contains a dead end
        bool containsDeadEnd(Node* root) {
            return hasDeadEnd(root, INT_MIN, INT_MAX);
        }
        
        // Main function to demonstrate the dead end check
        int main() {
            Node* root = NULL;
        
            // Insert values into the BST
            root = insert(root, 20);
            insert(root, 10);
            insert(root, 30);
            insert(root, 25);
            insert(root, 40);
            // Uncomment to create a dead end:
            // insert(root, 35);
        
            // Check for dead ends
            if (containsDeadEnd(root)) {
                printf("The BST contains a dead end.\n");
            } else {
                printf("The BST does not contain any dead ends.\n");
            }
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    The BST does not contain any dead ends.

        </pre>
    </div>


    <div class="d" id="d11">
        <h2>11.  CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function for inorder traversal to collect elements into an array
        void inorderTraversal(Node* root, int* arr, int* index) {
            if (root == NULL) return;
            inorderTraversal(root->left, arr, index);
            arr[(*index)++] = root->data; // Store the node data
            inorderTraversal(root->right, arr, index);
        }
        
        // Comparison function for qsort
        int compare(const void* a, const void* b) {
            return (*(int*)a - *(int*)b);
        }
        
        // Function to construct a balanced BST from the sorted array
        Node* sortedArrayToBST(int* arr, int start, int end) {
            if (start > end) return NULL;
        
            int mid = (start + end) / 2; // Find middle element
            Node* node = newNode(arr[mid]); // Create node
        
            // Recursively construct the left and right subtrees
            node->left = sortedArrayToBST(arr, start, mid - 1);
            node->right = sortedArrayToBST(arr, mid + 1, end);
            return node;
        }
        
        // Function to convert a binary tree to a binary search tree
        Node* convertToBST(Node* root) {
            if (root == NULL) return NULL;
        
            // Step 1: Get the number of nodes in the binary tree
            int n = 0;
            inorderTraversal(root, NULL, &n);
        
            // Step 2: Create an array to store the elements
            int* arr = (int*)malloc(n * sizeof(int));
            int index = 0;
            inorderTraversal(root, arr, &index); // Fill the array
        
            // Step 3: Sort the array
            qsort(arr, n, sizeof(int), compare);
        
            // Step 4: Construct the BST from the sorted array
            Node* bstRoot = sortedArrayToBST(arr, 0, n - 1);
        
            // Free the allocated array
            free(arr);
            return bstRoot;
        }
        
        // Function to print inorder traversal of the tree
        void printInorder(Node* root) {
            if (root == NULL) return;
            printInorder(root->left);
            printf("%d ", root->data);
            printInorder(root->right);
        }
        
        // Main function to demonstrate the conversion
        int main() {
            // Creating a binary tree
            Node* root = newNode(10);
            root->left = newNode(30);
            root->right = newNode(15);
            root->left->left = newNode(5);
            root->left->right = newNode(20);
            
            printf("Inorder traversal of the original binary tree:\n");
            printInorder(root);
            printf("\n");
        
            // Convert to BST
            Node* bstRoot = convertToBST(root);
        
            printf("Inorder traversal of the resulting binary search tree:\n");
            printInorder(bstRoot);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        


    <b id="b">Output:</b>
    Inorder traversal of the original binary tree:
    5 30 20 10 15 
    
    Inorder traversal of the resulting binary search tree:
    5 10 15 20 30 
        
        </pre>
    </div>


    <div class="d" id="d12">
        <h2>12. FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new value into the BST
        Node* insert(Node* root, int value) {
            if (root == NULL) {
                return newNode(value);
            }
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else {
                root->right = insert(root->right, value);
            }
            return root;
        }
        
        // Variable to store the Kth largest element and count
        int count = 0;
        int kthLargest = -1;
        
        // Function to perform reverse inorder traversal and find the Kth largest element
        void findKthLargest(Node* root, int K) {
            if (root == NULL || count >= K) return;
        
            // Traverse the right subtree first (largest element)
            findKthLargest(root->right, K);
        
            // Increment count and check if this is the Kth largest
            count++;
            if (count == K) {
                kthLargest = root->data; // Store the Kth largest element
                return;
            }
        
            // Traverse the left subtree
            findKthLargest(root->left, K);
        }
        
        // Main function to demonstrate finding the Kth largest element
        int main() {
            Node* root = NULL;
        
            // Insert values into the BST
            root = insert(root, 50);
            insert(root, 30);
            insert(root, 20);
            insert(root, 40);
            insert(root, 70);
            insert(root, 60);
            insert(root, 80);
        
            int K = 3; // Find the 3rd largest element
        
            findKthLargest(root, K);
        
            if (kthLargest != -1) {
                printf("The %dth largest element in the BST is: %d\n", K, kthLargest);
            } else {
                printf("The BST does not contain %d elements.\n", K);
            }
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    The 3rd largest element in the BST is: 60

        </pre>
    </div>


    <div class="d" id="d13">
        <h2>13. FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new value into the BST
        Node* insert(Node* root, int value) {
            if (root == NULL) {
                return newNode(value);
            }
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else {
                root->right = insert(root->right, value);
            }
            return root;
        }
        
        // Variable to store the Kth smallest element and count
        int count = 0;
        int kthSmallest = -1;
        
        // Function to perform inorder traversal and find the Kth smallest element
        void findKthSmallest(Node* root, int K) {
            if (root == NULL || count >= K) return;
        
            // Traverse the left subtree first (smallest element)
            findKthSmallest(root->left, K);
        
            // Increment count and check if this is the Kth smallest
            count++;
            if (count == K) {
                kthSmallest = root->data; // Store the Kth smallest element
                return;
            }
        
            // Traverse the right subtree
            findKthSmallest(root->right, K);
        }
        
        // Main function to demonstrate finding the Kth smallest element
        int main() {
            Node* root = NULL;
        
            // Insert values into the BST
            root = insert(root, 50);
            insert(root, 30);
            insert(root, 20);
            insert(root, 40);
            insert(root, 70);
            insert(root, 60);
            insert(root, 80);
        
            int K = 3; // Find the 3rd smallest element
        
            findKthSmallest(root, K);
        
            if (kthSmallest != -1) {
                printf("The %dth smallest element in the BST is: %d\n", K, kthSmallest);
            } else {
                printf("The BST does not contain %d elements.\n", K);
            }
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        
     

    <b id="b">Output:</b>
    The 3rd smallest element in the BST is: 40

        </pre>
    </div>


    <div class="d" id="d14">
        <h2>14. PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new value into the BST
        Node* insert(Node* root, int value) {
            if (root == NULL) {
                return newNode(value);
            }
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else {
                root->right = insert(root->right, value);
            }
            return root;
        }
        
        // Function to construct BST from preorder traversal
        Node* constructBSTFromPreorder(int* preorder, int* index, int size) {
            if (*index >= size) return NULL;
        
            Node* root = newNode(preorder[*index]);
            (*index)++;
        
            // Find the index where right subtree starts
            int rightIndex = *index;
            while (rightIndex < size && preorder[rightIndex] < root->data) {
                rightIndex++;
            }
        
            // Construct left and right subtrees
            root->left = constructBSTFromPreorder(preorder, index, rightIndex);
            root->right = constructBSTFromPreorder(preorder, index, size);
        
            return root;
        }
        
        // Function to perform postorder traversal and print nodes
        void postorderTraversal(Node* root) {
            if (root == NULL) return;
            postorderTraversal(root->left);
            postorderTraversal(root->right);
            printf("%d ", root->data);
        }
        
        // Main function to demonstrate the conversion from preorder to postorder
        int main() {
            int preorder[] = {10, 5, 1, 7, 40, 50};
            int size = sizeof(preorder) / sizeof(preorder[0]);
            int index = 0;
        
            // Construct the BST from preorder traversal
            Node* root = constructBSTFromPreorder(preorder, &index, size);
        
            // Print the postorder traversal
            printf("Postorder traversal of the constructed BST:\n");
            postorderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Postorder traversal of the constructed BST:
    1 7 5 50 40 10 

        </pre>
    </div>
    
    <div class="d" id="d15">
        <h2>15. CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to construct BST from preorder traversal
        Node* constructBSTFromPreorder(int* preorder, int* index, int size) {
            if (*index >= size) return NULL;
        
            // Create a new node for the current element
            Node* root = newNode(preorder[*index]);
            (*index)++;
        
            // If there are no more elements, return the node
            if (*index >= size) return root;
        
            // Find the first element greater than the root for the right subtree
            while (*index < size && preorder[*index] < root->data) {
                (*index)++;
            }
        
            // Construct left and right subtrees
            root->left = constructBSTFromPreorder(preorder, index, size);
            root->right = constructBSTFromPreorder(preorder, index, size);
        
            return root;
        }
        
        // Function to perform inorder traversal and print nodes
        void inorderTraversal(Node* root) {
            if (root == NULL) return;
            inorderTraversal(root->left);
            printf("%d ", root->data);
            inorderTraversal(root->right);
        }
        
        // Main function to demonstrate the construction from preorder traversal
        int main() {
            int preorder[] = {10, 5, 1, 7, 40, 50};
            int size = sizeof(preorder) / sizeof(preorder[0]);
            int index = 0;
        
            // Construct the BST from preorder traversal
            Node* root = constructBSTFromPreorder(preorder, &index, size);
        
            // Print the inorder traversal of the constructed BST
            printf("Inorder traversal of the constructed BST:\n");
            inorderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Inorder traversal of the constructed BST:
    1 5 7 10 40 50 
    
        </pre>
    </div>

    <div class="d" id="d16">
        <h2>16. CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to construct BST from postorder traversal
        Node* constructBSTFromPostorder(int* postorder, int* index, int min, int max, int size) {
            // Base case
            if (*index < 0) return NULL;
        
            int val = postorder[*index];
        
            // Check if the current value is within the allowed range
            if (val < min || val > max) return NULL;
        
            // Create a new node for the current value
            Node* root = newNode(val);
            (*index)--;
        
            // Since we are traversing in postorder, we first construct the right subtree,
            // then the left subtree.
            root->right = constructBSTFromPostorder(postorder, index, val, max, size);
            root->left = constructBSTFromPostorder(postorder, index, min, val, size);
        
            return root;
        }
        
        // Function to perform inorder traversal and print nodes
        void inorderTraversal(Node* root) {
            if (root == NULL) return;
            inorderTraversal(root->left);
            printf("%d ", root->data);
            inorderTraversal(root->right);
        }
        
        // Main function to demonstrate the construction from postorder traversal
        int main() {
            int postorder[] = {1, 7, 5, 50, 40, 10};
            int size = sizeof(postorder) / sizeof(postorder[0]);
            int index = size - 1; // Start from the last element
        
            // Construct the BST from postorder traversal
            Node* root = constructBSTFromPostorder(postorder, &index, INT_MIN, INT_MAX, size);
        
            // Print the inorder traversal of the constructed BST
            printf("Inorder traversal of the constructed BST:\n");
            inorderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        
            

    <b id="b">Output:</b>
    Inorder traversal of the constructed BST:
    1 5 7 10 40 50 
        
        </pre>
    </div>

    <div class="d" id="d17">
        <h2>17. CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            if (!node) {
                printf("Memory allocation failed\n");
                exit(1);
            }
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert nodes into the strictly binary tree
        Node* insertStrictlyBinary(Node* root, int data) {
            // If tree is empty, create the root node
            if (root == NULL) {
                return newNode(data);
            }
        
            // If the current root has no children, add the left child
            if (root->left == NULL) {
                root->left = newNode(data);
            }
            // If the current root has a left child but no right child, add the right child
            else if (root->right == NULL) {
                root->right = newNode(data);
            }
            // If both children are present, do not insert the new node, as we need to keep 
            it strictly binary
            else {
                printf("Node %d cannot be inserted; both children of node %d are already present.\n",
                 data, root->data);
                return root;
            }
            return root;
        }
        
        // Function to perform inorder traversal and print nodes
        void inorderTraversal(Node* root) {
            if (root == NULL) return;
            inorderTraversal(root->left);
            printf("%d ", root->data);
            inorderTraversal(root->right);
        }
        
        // Main function to demonstrate the construction of a strictly binary tree
        int main() {
            Node* root = NULL;
            int numNodes, value;
        
            printf("Enter the number of nodes you want to add (must be even for strictly binary tree): ");
            scanf("%d", &numNodes);
        
            // Check if the number of nodes is valid
            if (numNodes % 2 != 0) {
                printf("Please enter an even number of nodes.\n");
                return 1;
            }
        
            for (int i = 0; i < numNodes; i++) {
                printf("Enter value for node %d: ", i + 1);
                scanf("%d", &value);
                root = insertStrictlyBinary(root, value);
            }
        
            // Print the inorder traversal of the constructed strictly binary tree
            printf("Inorder traversal of the constructed strictly binary tree:\n");
            inorderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        
        

    <b id="b">Output:</b>
    Enter the number of nodes you want to add (must be even for strictly binary tree): 4
    Enter value for node 1: 10
    Enter value for node 2: 20
    Enter value for node 3: 30
    Enter value for node 4: 40
    Inorder traversal of the constructed strictly binary tree:
    20 10 30 40 
        
        </pre>
    </div>

    <div class="d" id="d18">
        <h2>18. CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            if (!node) {
                printf("Memory allocation failed\n");
                exit(1);
            }
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert nodes into the almost complete binary tree
        Node* insertAlmostComplete(Node* root, int data) {
            // If the tree is empty, create the root node
            if (root == NULL) {
                return newNode(data);
            }
        
            // Use a queue to perform level order insertion
            Node** queue = (Node**)malloc(sizeof(Node*) * 100); // Static allocation for simplicity
            int front = 0, rear = 0;
        
            // Enqueue the root node
            queue[rear++] = root;
        
            // Perform level order insertion
            while (front < rear) {
                Node* current = queue[front++];
        
                // Check left child
                if (current->left != NULL) {
                    queue[rear++] = current->left;
                } else {
                    current->left = newNode(data);
                    free(queue);
                    return root; // Node inserted, exit
                }
        
                // Check right child
                if (current->right != NULL) {
                    queue[rear++] = current->right;
                } else {
                    current->right = newNode(data);
                    free(queue);
                    return root; // Node inserted, exit
                }
            }
        
            free(queue);
            return root; // This should not be reached
        }
        
        // Function to perform inorder traversal and print nodes
        void inorderTraversal(Node* root) {
            if (root == NULL) return;
            inorderTraversal(root->left);
            printf("%d ", root->data);
            inorderTraversal(root->right);
        }
        
        // Main function to demonstrate the construction of an almost complete binary tree
        int main() {
            Node* root = NULL;
            int numNodes, value;
        
            printf("Enter the number of nodes you want to add: ");
            scanf("%d", &numNodes);
        
            for (int i = 0; i < numNodes; i++) {
                printf("Enter value for node %d: ", i + 1);
                scanf("%d", &value);
                root = insertAlmostComplete(root, value);
            }
        
            // Print the inorder traversal of the constructed almost complete binary tree
            printf("Inorder traversal of the constructed almost complete binary tree:\n");
            inorderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        


    <b id="b">Output:</b>
    Enter the number of nodes you want to add: 6
    Enter value for node 1: 10
    Enter value for node 2: 20
    Enter value for node 3: 30
    Enter value for node 4: 40
    Enter value for node 5: 50
    Enter value for node 6: 60
    Inorder traversal of the constructed almost complete binary tree:
    40 20 50 10 30 60 
        
        </pre>
    </div>

    <div class="d" id="d19">
        <h2>19. CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            if (!node) {
                printf("Memory allocation failed\n");
                exit(1);
            }
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert nodes into the complete binary tree
        Node* insertCompleteBinaryTree(Node* root, int data) {
            if (root == NULL) {
                return newNode(data);
            }
        
            Node** queue = (Node**)malloc(sizeof(Node*) * 100); // Static allocation for simplicity
            int front = 0, rear = 0;
        
            // Enqueue the root node
            queue[rear++] = root;
        
            // Perform level order insertion
            while (front < rear) {
                Node* current = queue[front++];
        
                // Check left child
                if (current->left != NULL) {
                    queue[rear++] = current->left;
                } else {
                    current->left = newNode(data);
                    free(queue);
                    return root; // Node inserted, exit
                }
        
                // Check right child
                if (current->right != NULL) {
                    queue[rear++] = current->right;
                } else {
                    current->right = newNode(data);
                    free(queue);
                    return root; // Node inserted, exit
                }
            }
        
            free(queue);
            return root; // This should not be reached
        }
        
        // Function to perform inorder traversal and print nodes
        void inorderTraversal(Node* root) {
            if (root == NULL) return;
            inorderTraversal(root->left);
            printf("%d ", root->data);
            inorderTraversal(root->right);
        }
        
        // Main function to demonstrate the construction of a complete binary tree
        int main() {
            Node* root = NULL;
            int numNodes, value;
        
            printf("Enter the number of nodes you want to add: ");
            scanf("%d", &numNodes);
        
            for (int i = 0; i < numNodes; i++) {
                printf("Enter value for node %d: ", i + 1);
                scanf("%d", &value);
                root = insertCompleteBinaryTree(root, value);
            }
        
            // Print the inorder traversal of the constructed complete binary tree
            printf("Inorder traversal of the constructed complete binary tree:\n");
            inorderTraversal(root);
            printf("\n");
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Enter the number of nodes you want to add: 6
    Enter value for node 1: 10
    Enter value for node 2: 20
    Enter value for node 3: 30
    Enter value for node 4: 40
    Enter value for node 5: 50
    Enter value for node 6: 60
    Inorder traversal of the constructed complete binary tree:
    40 20 50 10 30 60 
        
        </pre>
    </div>

    <div class="d" id="d20">
        <h2>20. COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Definition of a binary search tree node
        typedef struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        } Node;
        
        // Function to create a new tree node
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            if (!node) {
                printf("Memory allocation failed\n");
                exit(1);
            }
            node->data = data;
            node->left = NULL;
            node->right = NULL;
            return node;
        }
        
        // Function to insert a new node in the BST
        Node* insert(Node* root, int data) {
            if (root == NULL) {
                return newNode(data);
            }
            if (data < root->data) {
                root->left = insert(root->left, data);
            } else {
                root->right = insert(root->right, data);
            }
            return root;
        }
        
        // Function to count the number of nodes in the BST
        int countNodes(Node* root) {
            if (root == NULL) {
                return 0;
            }
            return 1 + countNodes(root->left) + countNodes(root->right);
        }
        
        // Main function to demonstrate counting nodes in the BST
        int main() {
            Node* root = NULL;
            int numNodes, value;
        
            printf("Enter the number of nodes you want to add: ");
            scanf("%d", &numNodes);
        
            for (int i = 0; i < numNodes; i++) {
                printf("Enter value for node %d: ", i + 1);
                scanf("%d", &value);
                root = insert(root, value);
            }
        
            // Count and print the number of nodes in the BST
            int totalNodes = countNodes(root);
            printf("Total number of nodes in the BST: %d\n", totalNodes);
        
            // Freeing memory would go here (not implemented for brevity)
        
            return 0;
        }
        
      

    <b id="b">Output:</b>
    Enter the number of nodes you want to add: 5
    Enter value for node 1: 30
    Enter value for node 2: 20
    Enter value for node 3: 40
    Enter value for node 4: 10
    Enter value for node 5: 25
    Total number of nodes in the BST: 5
        
        </pre>
    </div>

   
</body>
</html>
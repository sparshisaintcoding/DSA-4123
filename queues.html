<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unit1</title>
    <link rel="stylesheet" href="programs.css">
</head>
<body>
    <div class="d" id="d1">
        <h2>1. IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        #define MAX 5 // Define the maximum size of the queue
        
        // Define the structure for the Queue
        struct Queue {
            int items[MAX];
            int front;
            int rear;
        };
        
        // Function to create and initialize the queue
        struct Queue* createQueue() {
            struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
            q->front = -1;
            q->rear = -1;
            return q;
        }
        
        // Function to check if the queue is empty
        int isEmpty(struct Queue* q) {
            return (q->front == -1);
        }
        
        // Function to check if the queue is full
        int isFull(struct Queue* q) {
            return (q->rear == MAX - 1);
        }
        
        // Function to insert an element into the queue
        void insert(struct Queue* q, int value) {
            if (isFull(q)) {
                printf("Queue is full! Cannot insert %d\n", value);
                return;
            }
            if (isEmpty(q)) {
                q->front = 0; // Initialize front if the queue was empty
            }
            q->rear++;
            q->items[q->rear] = value;
            printf("%d inserted into the queue\n", value);
        }
        
        // Function to delete an element from the queue
        int delete(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot delete\n");
                return -1; // Indicate that the queue is empty
            }
            int deletedValue = q->items[q->front];
            if (q->front == q->rear) {
                // Queue has only one element, reset the queue
                q->front = -1;
                q->rear = -1;
            } else {
                q->front++; // Move front forward
            }
            printf("%d deleted from the queue\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the queue
        int peek(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot peek\n");
                return -1; // Indicate that the queue is empty
            }
            return q->items[q->front];
        }
        
        // Function to display the queue
        void display(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty!\n");
                return;
            }
            printf("Queue elements: ");
            for (int i = q->front; i <= q->rear; i++) {
                printf("%d ", q->items[i]);
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct Queue* q = createQueue();
            
            int choice, value;
        
            do {
                printf("\nQueue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Check if Full\n");
                printf("7. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert: ");
                        scanf("%d", &value);
                        insert(q, value);
                        break;
                    case 2:
                        delete(q);
                        break;
                    case 3:
                        value = peek(q);
                        if (value != -1) {
                            printf("Front element is: %d\n", value);
                        }
                        break;
                    case 4:
                        display(q);
                        break;
                    case 5:
                        if (isEmpty(q)) {
                            printf("Queue is empty\n");
                        } else {
                            printf("Queue is not empty\n");
                        }
                        break;
                    case 6:
                        if (isFull(q)) {
                            printf("Queue is full\n");
                        } else {
                            printf("Queue is not full\n");
                        }
                        break;
                    case 7:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 7);
        
            free(q); // Free the allocated memory for the queue
            return 0;
        }
        

    <b id="b">Output:</b>
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter value to insert: 10
    10 inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter value to insert: 20
    20 inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 4
    Queue elements: 10 20 
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 2
    10 deleted from the queue
        
        </pre>
    </div>


    <div class="d" id="d2">
        <h2>2. IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX 5 // Define the maximum size of the queue
        #define STR_LEN 100 // Define the maximum length of each string
        
        // Define the structure for the Queue
        struct Queue {
            char items[MAX][STR_LEN];
            int front;
            int rear;
        };
        
        // Function to create and initialize the queue
        struct Queue* createQueue() {
            struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
            q->front = -1;
            q->rear = -1;
            return q;
        }
        
        // Function to check if the queue is empty
        int isEmpty(struct Queue* q) {
            return (q->front == -1);
        }
        
        // Function to check if the queue is full
        int isFull(struct Queue* q) {
            return (q->rear == MAX - 1);
        }
        
        // Function to insert an element into the queue
        void insert(struct Queue* q, char* value) {
            if (isFull(q)) {
                printf("Queue is full! Cannot insert '%s'\n", value);
                return;
            }
            if (isEmpty(q)) {
                q->front = 0; // Initialize front if the queue was empty
            }
            q->rear++;
            strcpy(q->items[q->rear], value);
            printf("'%s' inserted into the queue\n", value);
        }
        
        // Function to delete an element from the queue
        char* delete(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot delete\n");
                return NULL; // Indicate that the queue is empty
            }
            char* deletedValue = q->items[q->front];
            if (q->front == q->rear) {
                // Queue has only one element, reset the queue
                q->front = -1;
                q->rear = -1;
            } else {
                q->front++; // Move front forward
            }
            printf("'%s' deleted from the queue\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the queue
        char* peek(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot peek\n");
                return NULL; // Indicate that the queue is empty
            }
            return q->items[q->front];
        }
        
        // Function to display the queue
        void display(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty!\n");
                return;
            }
            printf("Queue elements: ");
            for (int i = q->front; i <= q->rear; i++) {
                printf("'%s' ", q->items[i]);
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct Queue* q = createQueue();
            
            int choice;
            char value[STR_LEN];
        
            do {
                printf("\nQueue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Check if Full\n");
                printf("7. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // Consume the newline character
        
                switch (choice) {
                    case 1:
                        printf("Enter string to insert: ");
                        fgets(value, STR_LEN, stdin);
                        value[strcspn(value, "\n")] = 0; // Remove the newline character
                        insert(q, value);
                        break;
                    case 2:
                        delete(q);
                        break;
                    case 3:
                        {
                            char* frontValue = peek(q);
                            if (frontValue != NULL) {
                                printf("Front element is: '%s'\n", frontValue);
                            }
                        }
                        break;
                    case 4:
                        display(q);
                        break;
                    case 5:
                        if (isEmpty(q)) {
                            printf("Queue is empty\n");
                        } else {
                            printf("Queue is not empty\n");
                        }
                        break;
                    case 6:
                        if (isFull(q)) {
                            printf("Queue is full\n");
                        } else {
                            printf("Queue is not full\n");
                        }
                        break;
                    case 7:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 7);
        
            free(q); // Free the allocated memory for the queue
            return 0;
        }
        

    <b id="b">Output:</b>
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter string to insert: Hello
    'Hello' inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter string to insert: World
    'World' inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 4
    Queue elements: 'Hello' 'World' 
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 2
    'Hello' deleted from the queue
        
        </pre>
    </div>


    <div class="d" id="d3">
        <h2>3. IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Define the structure for a queue node
        struct Node {
            int data;
            struct Node* next;
        };
        
        // Define the structure for the Queue
        struct Queue {
            struct Node* front;
            struct Node* rear;
        };
        
        // Function to create and initialize the queue
        struct Queue* createQueue() {
            struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
            q->front = NULL;
            q->rear = NULL;
            return q;
        }
        
        // Function to check if the queue is empty
        int isEmpty(struct Queue* q) {
            return (q->front == NULL);
        }
        
        // Function to insert an element into the queue
        void insert(struct Queue* q, int value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = value;
            newNode->next = NULL;
            
            if (q->rear == NULL) {
                // Queue is empty
                q->front = newNode;
                q->rear = newNode;
            } else {
                // Add the new node at the end and update rear
                q->rear->next = newNode;
                q->rear = newNode;
            }
            printf("%d inserted into the queue\n", value);
        }
        
        // Function to delete an element from the queue
        int delete(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot delete\n");
                return -1; // Indicate that the queue is empty
            }
            struct Node* temp = q->front;
            int deletedValue = temp->data;
            
            q->front = q->front->next;
            if (q->front == NULL) {
                // Queue is now empty
                q->rear = NULL;
            }
            
            free(temp);
            printf("%d deleted from the queue\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the queue
        int peek(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot peek\n");
                return -1; // Indicate that the queue is empty
            }
            return q->front->data;
        }
        
        // Function to display the queue
        void display(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty!\n");
                return;
            }
            struct Node* current = q->front;
            printf("Queue elements: ");
            while (current != NULL) {
                printf("%d ", current->data);
                current = current->next;
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct Queue* q = createQueue();
            
            int choice, value;
        
            do {
                printf("\nQueue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert: ");
                        scanf("%d", &value);
                        insert(q, value);
                        break;
                    case 2:
                        delete(q);
                        break;
                    case 3:
                        value = peek(q);
                        if (value != -1) {
                            printf("Front element is: %d\n", value);
                        }
                        break;
                    case 4:
                        display(q);
                        break;
                    case 5:
                        if (isEmpty(q)) {
                            printf("Queue is empty\n");
                        } else {
                            printf("Queue is not empty\n");
                        }
                        break;
                    case 6:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 6);
        
            // Free remaining nodes
            while (!isEmpty(q)) {
                delete(q);
            }
            
            free(q); // Free the allocated memory for the queue
            return 0;
        }
        
        

    <b id="b">Output:</b>
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 1
    Enter value to insert: 10
    10 inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 1
    Enter value to insert: 20
    20 inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 4
    Queue elements: 10 20 
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 2
    10 deleted from the queue
        
        </pre>
    </div>


    <div class="d" id="d4">
        <h2>4. IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define STR_LEN 100 // Maximum length for each string
        
        // Define the structure for a queue node
        struct Node {
            char data[STR_LEN];
            struct Node* next;
        };
        
        // Define the structure for the Queue
        struct Queue {
            struct Node* front;
            struct Node* rear;
        };
        
        // Function to create and initialize the queue
        struct Queue* createQueue() {
            struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
            q->front = NULL;
            q->rear = NULL;
            return q;
        }
        
        // Function to check if the queue is empty
        int isEmpty(struct Queue* q) {
            return (q->front == NULL);
        }
        
        // Function to insert an element into the queue
        void insert(struct Queue* q, const char* value) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            strncpy(newNode->data, value, STR_LEN);
            newNode->next = NULL;
        
            if (q->rear == NULL) {
                // Queue is empty
                q->front = newNode;
                q->rear = newNode;
            } else {
                // Add the new node at the end and update rear
                q->rear->next = newNode;
                q->rear = newNode;
            }
            printf("'%s' inserted into the queue\n", value);
        }
        
        // Function to delete an element from the queue
        char* delete(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot delete\n");
                return NULL; // Indicate that the queue is empty
            }
            struct Node* temp = q->front;
            char* deletedValue = strdup(temp->data); // Duplicate the string for return
        
            q->front = q->front->next;
            if (q->front == NULL) {
                // Queue is now empty
                q->rear = NULL;
            }
            
            free(temp);
            printf("'%s' deleted from the queue\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the queue
        char* peek(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot peek\n");
                return NULL; // Indicate that the queue is empty
            }
            return q->front->data;
        }
        
        // Function to display the queue
        void display(struct Queue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty!\n");
                return;
            }
            struct Node* current = q->front;
            printf("Queue elements: ");
            while (current != NULL) {
                printf("'%s' ", current->data);
                current = current->next;
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct Queue* q = createQueue();
            
            int choice;
            char value[STR_LEN];
        
            do {
                printf("\nQueue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // Consume the newline character
        
                switch (choice) {
                    case 1:
                        printf("Enter string to insert: ");
                        fgets(value, STR_LEN, stdin);
                        value[strcspn(value, "\n")] = 0; // Remove the newline character
                        insert(q, value);
                        break;
                    case 2:
                        {
                            char* deletedValue = delete(q);
                            if (deletedValue != NULL) {
                                free(deletedValue); // Free the duplicated string
                            }
                        }
                        break;
                    case 3:
                        {
                            char* frontValue = peek(q);
                            if (frontValue != NULL) {
                                printf("Front element is: '%s'\n", frontValue);
                            }
                        }
                        break;
                    case 4:
                        display(q);
                        break;
                    case 5:
                        if (isEmpty(q)) {
                            printf("Queue is empty\n");
                        } else {
                            printf("Queue is not empty\n");
                        }
                        break;
                    case 6:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 6);
        
            // Free remaining nodes
            while (!isEmpty(q)) {
                char* deletedValue = delete(q);
                if (deletedValue != NULL) {
                    free(deletedValue);
                }
            }
        
            free(q); // Free the allocated memory for the queue
            return 0;
        }
        

    <b id="b">Output:</b>
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 1
    Enter string to insert: Hello
    'Hello' inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 1
    Enter string to insert: World
    'World' inserted into the queue
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 4
    Queue elements: 'Hello' 'World' 
    
    Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 2
    'Hello' deleted from the queue
        
        </pre>
    </div>
    
    <div class="d" id="d5">
        <h2>5. IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        #define MAX_SIZE 5 // Define the maximum size of the circular queue
        
        // Define the structure for the Circular Queue
        struct CircularQueue {
            int items[MAX_SIZE];
            int front;
            int rear;
        };
        
        // Function to create and initialize the circular queue
        struct CircularQueue* createQueue() {
            struct CircularQueue* q = (struct CircularQueue*)malloc(sizeof(struct CircularQueue));
            q->front = -1;
            q->rear = -1;
            return q;
        }
        
        // Function to check if the queue is empty
        int isEmpty(struct CircularQueue* q) {
            return (q->front == -1);
        }
        
        // Function to check if the queue is full
        int isFull(struct CircularQueue* q) {
            return (q->front == (q->rear + 1) % MAX_SIZE);
        }
        
        // Function to insert an element into the circular queue
        void insert(struct CircularQueue* q, int value) {
            if (isFull(q)) {
                printf("Queue is full! Cannot insert %d\n", value);
                return;
            }
            if (isEmpty(q)) {
                q->front = 0; // Initialize front when first element is added
            }
            q->rear = (q->rear + 1) % MAX_SIZE; // Move rear to next position
            q->items[q->rear] = value;
            printf("%d inserted into the queue\n", value);
        }
        
        // Function to delete an element from the circular queue
        int delete(struct CircularQueue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot delete\n");
                return -1; // Indicate that the queue is empty
            }
            int deletedValue = q->items[q->front];
            if (q->front == q->rear) {
                // Queue will be empty after this deletion
                q->front = -1;
                q->rear = -1;
            } else {
                // Move front to next position
                q->front = (q->front + 1) % MAX_SIZE;
            }
            printf("%d deleted from the queue\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the circular queue
        int peek(struct CircularQueue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot peek\n");
                return -1; // Indicate that the queue is empty
            }
            return q->items[q->front];
        }
        
        // Function to display the circular queue
        void display(struct CircularQueue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty!\n");
                return;
            }
            printf("Queue elements: ");
            int i = q->front;
            while (1) {
                printf("%d ", q->items[i]);
                if (i == q->rear) {
                    break;
                }
                i = (i + 1) % MAX_SIZE;
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct CircularQueue* q = createQueue();
            
            int choice, value;
        
            do {
                printf("\nCircular Queue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Check if Full\n");
                printf("7. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert: ");
                        scanf("%d", &value);
                        insert(q, value);
                        break;
                    case 2:
                        delete(q);
                        break;
                    case 3:
                        value = peek(q);
                        if (value != -1) {
                            printf("Front element is: %d\n", value);
                        }
                        break;
                    case 4:
                        display(q);
                        break;
                    case 5:
                        if (isEmpty(q)) {
                            printf("Queue is empty\n");
                        } else {
                            printf("Queue is not empty\n");
                        }
                        break;
                    case 6:
                        if (isFull(q)) {
                            printf("Queue is full\n");
                        } else {
                            printf("Queue is not full\n");
                        }
                        break;
                    case 7:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 7);
        
            free(q); // Free the allocated memory for the queue
            return 0;
        }
        

    <b id="b">Output:</b>
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter value to insert: 10
    10 inserted into the queue
    
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter value to insert: 20
    20 inserted into the queue
    
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 4
    Queue elements: 10 20 
    
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 2
    10 deleted from the queue
        
        </pre>
    </div>

    <div class="d" id="d6">
        <h2>6. IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_SIZE 5    // Define the maximum size of the circular queue
        #define STR_LEN 100   // Define the maximum length for each string
        
        // Define the structure for the Circular Queue
        struct CircularQueue {
            char items[MAX_SIZE][STR_LEN]; // Array to hold strings
            int front;
            int rear;
        };
        
        // Function to create and initialize the circular queue
        struct CircularQueue* createQueue() {
            struct CircularQueue* q = (struct CircularQueue*)malloc(sizeof(struct CircularQueue));
            q->front = -1;
            q->rear = -1;
            return q;
        }
        
        // Function to check if the queue is empty
        int isEmpty(struct CircularQueue* q) {
            return (q->front == -1);
        }
        
        // Function to check if the queue is full
        int isFull(struct CircularQueue* q) {
            return (q->front == (q->rear + 1) % MAX_SIZE);
        }
        
        // Function to insert a string into the circular queue
        void insert(struct CircularQueue* q, const char* value) {
            if (isFull(q)) {
                printf("Queue is full! Cannot insert '%s'\n", value);
                return;
            }
            if (isEmpty(q)) {
                q->front = 0; // Initialize front when first element is added
            }
            q->rear = (q->rear + 1) % MAX_SIZE; // Move rear to next position
            strncpy(q->items[q->rear], value, STR_LEN);
            printf("'%s' inserted into the queue\n", value);
        }
        
        // Function to delete a string from the circular queue
        char* delete(struct CircularQueue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot delete\n");
                return NULL; // Indicate that the queue is empty
            }
            char* deletedValue = strdup(q->items[q->front]); // Duplicate the string for return
            if (q->front == q->rear) {
                // Queue will be empty after this deletion
                q->front = -1;
                q->rear = -1;
            } else {
                // Move front to next position
                q->front = (q->front + 1) % MAX_SIZE;
            }
            printf("'%s' deleted from the queue\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the circular queue
        char* peek(struct CircularQueue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty! Cannot peek\n");
                return NULL; // Indicate that the queue is empty
            }
            return q->items[q->front];
        }
        
        // Function to display the circular queue
        void display(struct CircularQueue* q) {
            if (isEmpty(q)) {
                printf("Queue is empty!\n");
                return;
            }
            printf("Queue elements: ");
            int i = q->front;
            while (1) {
                printf("'%s' ", q->items[i]);
                if (i == q->rear) {
                    break;
                }
                i = (i + 1) % MAX_SIZE;
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct CircularQueue* q = createQueue();
            
            int choice;
            char value[STR_LEN];
        
            do {
                printf("\nCircular Queue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Check if Full\n");
                printf("7. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // Consume the newline character
        
                switch (choice) {
                    case 1:
                        printf("Enter string to insert: ");
                        fgets(value, STR_LEN, stdin);
                        value[strcspn(value, "\n")] = 0; // Remove the newline character
                        insert(q, value);
                        break;
                    case 2:
                        {
                            char* deletedValue = delete(q);
                            if (deletedValue != NULL) {
                                free(deletedValue); // Free the duplicated string
                            }
                        }
                        break;
                    case 3:
                        {
                            char* frontValue = peek(q);
                            if (frontValue != NULL) {
                                printf("Front element is: '%s'\n", frontValue);
                            }
                        }
                        break;
                    case 4:
                        display(q);
                        break;
                    case 5:
                        if (isEmpty(q)) {
                            printf("Queue is empty\n");
                        } else {
                            printf("Queue is not empty\n");
                        }
                        break;
                    case 6:
                        if (isFull(q)) {
                            printf("Queue is full\n");
                        } else {
                            printf("Queue is not full\n");
                        }
                        break;
                    case 7:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 7);
        
            // Free remaining nodes
            while (!isEmpty(q)) {
                char* deletedValue = delete(q);
                if (deletedValue != NULL) {
                    free(deletedValue);
                }
            }
        
            free(q); // Free the allocated memory for the queue
            return 0;
        }
        

    <b id="b">Output:</b>
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter string to insert: Hello
    'Hello' inserted into the queue
    
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter string to insert: World
    'World' inserted into the queue
    
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 4
    Queue elements: 'Hello' 'World' 
    
    Circular Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 2
    'Hello' deleted from the queue
        
        </pre>
    </div>

    <div class="d" id="d7">
        <h2>7. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        #define MAX_SIZE 5 // Define the maximum size of the priority queue
        
        // Define the structure for the Priority Queue
        struct PriorityQueue {
            int items[MAX_SIZE];
            int size;
        };
        
        // Function to create and initialize the priority queue
        struct PriorityQueue* createQueue() {
            struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
            pq->size = 0;
            return pq;
        }
        
        // Function to check if the priority queue is empty
        int isEmpty(struct PriorityQueue* pq) {
            return (pq->size == 0);
        }
        
        // Function to check if the priority queue is full
        int isFull(struct PriorityQueue* pq) {
            return (pq->size == MAX_SIZE);
        }
        
        // Function to insert an element into the priority queue
        void insert(struct PriorityQueue* pq, int value) {
            if (isFull(pq)) {
                printf("Priority Queue is full! Cannot insert %d\n", value);
                return;
            }
            // Insert the new element at the end
            pq->items[pq->size] = value;
            pq->size++;
        
            // Rearrange the elements to maintain priority order
            int i = pq->size - 1;
            while (i > 0 && pq->items[i] < pq->items[(i - 1) / 2]) {
                // Swap with parent
                int temp = pq->items[i];
                pq->items[i] = pq->items[(i - 1) / 2];
                pq->items[(i - 1) / 2] = temp;
                i = (i - 1) / 2; // Move to parent index
            }
            printf("%d inserted into the priority queue\n", value);
        }
        
        // Function to delete the highest priority element from the priority queue
        int delete(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty! Cannot delete\n");
                return -1; // Indicate that the queue is empty
            }
        
            int highestPriority = pq->items[0]; // Get the highest priority element
            pq->items[0] = pq->items[pq->size - 1]; // Move the last element to the root
            pq->size--;
        
            // Rearrange the elements to maintain priority order
            int i = 0;
            while (1) {
                int leftChild = 2 * i + 1;
                int rightChild = 2 * i + 2;
                int smallest = i;
        
                if (leftChild < pq->size && pq->items[leftChild] < pq->items[smallest]) {
                    smallest = leftChild;
                }
                if (rightChild < pq->size && pq->items[rightChild] < pq->items[smallest]) {
                    smallest = rightChild;
                }
                if (smallest == i) break; // If no swap is needed, break
        
                // Swap the current element with the smallest child
                int temp = pq->items[i];
                pq->items[i] = pq->items[smallest];
                pq->items[smallest] = temp;
                i = smallest; // Move down to the smallest child
            }
        
            printf("%d deleted from the priority queue\n", highestPriority);
            return highestPriority;
        }
        
        // Function to peek at the highest priority element of the priority queue
        int peek(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty! Cannot peek\n");
                return -1; // Indicate that the queue is empty
            }
            return pq->items[0]; // The highest priority element is at the root
        }
        
        // Function to display the priority queue
        void display(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty!\n");
                return;
            }
            printf("Priority Queue elements: ");
            for (int i = 0; i < pq->size; i++) {
                printf("%d ", pq->items[i]);
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct PriorityQueue* pq = createQueue();
            
            int choice, value;
        
            do {
                printf("\nPriority Queue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Check if Full\n");
                printf("7. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert: ");
                        scanf("%d", &value);
                        insert(pq, value);
                        break;
                    case 2:
                        delete(pq);
                        break;
                    case 3:
                        value = peek(pq);
                        if (value != -1) {
                            printf("Highest priority element is: %d\n", value);
                        }
                        break;
                    case 4:
                        display(pq);
                        break;
                    case 5:
                        if (isEmpty(pq)) {
                            printf("Priority Queue is empty\n");
                        } else {
                            printf("Priority Queue is not empty\n");
                        }
                        break;
                    case 6:
                        if (isFull(pq)) {
                            printf("Priority Queue is full\n");
                        } else {
                            printf("Priority Queue is not full\n");
                        }
                        break;
                    case 7:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 7);
        
            free(pq); // Free the allocated memory for the queue
            return 0;
        }
        

    <b id="b">Output:</b>
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter value to insert: 30
    30 inserted into the priority queue
    
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter value to insert: 20
    20 inserted into the priority queue
    
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 4
    Priority Queue elements: 20 30 
    
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 2
    20 deleted from the priority queue
        
        </pre>
    </div>

    <div class="d" id="d8">
        <h2>8. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_SIZE 5    // Define the maximum size of the priority queue
        #define STR_LEN 100   // Define the maximum length for each string
        
        // Define the structure for the Priority Queue
        struct PriorityQueue {
            char items[MAX_SIZE][STR_LEN];
            int size;
        };
        
        // Function to create and initialize the priority queue
        struct PriorityQueue* createQueue() {
            struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
            pq->size = 0;
            return pq;
        }
        
        // Function to check if the priority queue is empty
        int isEmpty(struct PriorityQueue* pq) {
            return (pq->size == 0);
        }
        
        // Function to check if the priority queue is full
        int isFull(struct PriorityQueue* pq) {
            return (pq->size == MAX_SIZE);
        }
        
        // Function to insert an element into the priority queue
        void insert(struct PriorityQueue* pq, const char* value) {
            if (isFull(pq)) {
                printf("Priority Queue is full! Cannot insert '%s'\n", value);
                return;
            }
            // Insert the new element at the end
            strcpy(pq->items[pq->size], value);
            pq->size++;
        
            // Rearrange the elements to maintain priority order
            int i = pq->size - 1;
            while (i > 0 && strcmp(pq->items[i], pq->items[(i - 1) / 2]) < 0) {
                // Swap with parent
                char temp[STR_LEN];
                strcpy(temp, pq->items[i]);
                strcpy(pq->items[i], pq->items[(i - 1) / 2]);
                strcpy(pq->items[(i - 1) / 2], temp);
                i = (i - 1) / 2; // Move to parent index
            }
            printf("'%s' inserted into the priority queue\n", value);
        }
        
        // Function to delete the highest priority element from the priority queue
        char* delete(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty! Cannot delete\n");
                return NULL; // Indicate that the queue is empty
            }
        
            char* highestPriority = strdup(pq->items[0]); // Duplicate the highest priority string
            pq->items[0][0] = '\0'; // Clear the root
        
            // Move the last element to the root
            strcpy(pq->items[0], pq->items[pq->size - 1]);
            pq->size--;
        
            // Rearrange the elements to maintain priority order
            int i = 0;
            while (1) {
                int leftChild = 2 * i + 1;
                int rightChild = 2 * i + 2;
                int smallest = i;
        
                if (leftChild < pq->size && strcmp(pq->items[leftChild], pq->items[smallest]) < 0) {
                    smallest = leftChild;
                }
                if (rightChild < pq->size && strcmp(pq->items[rightChild], pq->items[smallest]) < 0)
                {
                    smallest = rightChild;
                }
                if (smallest == i) break; // If no swap is needed, break
        
                // Swap the current element with the smallest child
                char temp[STR_LEN];
                strcpy(temp, pq->items[i]);
                strcpy(pq->items[i], pq->items[smallest]);
                strcpy(pq->items[smallest], temp);
                i = smallest; // Move down to the smallest child
            }
        
            printf("'%s' deleted from the priority queue\n", highestPriority);
            return highestPriority; // Return the deleted string
        }
        
        // Function to peek at the highest priority element of the priority queue
        char* peek(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty! Cannot peek\n");
                return NULL; // Indicate that the queue is empty
            }
            return pq->items[0]; // The highest priority element is at the root
        }
        
        // Function to display the priority queue
        void display(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty!\n");
                return;
            }
            printf("Priority Queue elements: ");
            for (int i = 0; i < pq->size; i++) {
                printf("'%s' ", pq->items[i]);
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct PriorityQueue* pq = createQueue();
            
            int choice;
            char value[STR_LEN];
        
            do {
                printf("\nPriority Queue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Peek\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Check if Full\n");
                printf("7. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // Consume the newline character
        
                switch (choice) {
                    case 1:
                        printf("Enter string to insert: ");
                        fgets(value, STR_LEN, stdin);
                        value[strcspn(value, "\n")] = 0; // Remove the newline character
                        insert(pq, value);
                        break;
                    case 2:
                        {
                            char* deletedValue = delete(pq);
                            if (deletedValue != NULL) {
                                free(deletedValue); // Free the duplicated string
                            }
                        }
                        break;
                    case 3:
                        {
                            char* frontValue = peek(pq);
                            if (frontValue != NULL) {
                                printf("Highest priority element is: '%s'\n", frontValue);
                            }
                        }
                        break;
                    case 4:
                        display(pq);
                        break;
                    case 5:
                        if (isEmpty(pq)) {
                            printf("Priority Queue is empty\n");
                        } else {
                            printf("Priority Queue is not empty\n");
                        }
                        break;
                    case 6:
                        if (isFull(pq)) {
                            printf("Priority Queue is full\n");
                        } else {
                            printf("Priority Queue is not full\n");
                        }
                        break;
                    case 7:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 7);
        
            // Free remaining nodes
            free(pq); // Free the allocated memory for the queue
            return 0;
        }
          
                

    <b id="b">Output:</b>
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter string to insert: apple
    'apple' inserted into the priority queue
    
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 1
    Enter string to insert: banana
    'banana' inserted into the priority queue
    
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 4
    Priority Queue elements: 'apple' 'banana' 
    
    Priority Queue Operations:
    1. Insert
    2. Delete
    3. Peek
    4. Display
    5. Check if Empty
    6. Check if Full
    7. Exit
    Enter your choice: 2
    'apple' deleted from the priority queue
        
        </pre>
    </div>

    <div class="d" id="d9">
        <h2>9.  IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        #define MAX_SIZE 5 // Define the maximum size of the deque
        
        // Define the structure for the Deque
        struct Deque {
            int items[MAX_SIZE];
            int front;
            int rear;
        };
        
        // Function to create and initialize the deque
        struct Deque* createDeque() {
            struct Deque* dq = (struct Deque*)malloc(sizeof(struct Deque));
            dq->front = -1;
            dq->rear = -1;
            return dq;
        }
        
        // Function to check if the deque is empty
        int isEmpty(struct Deque* dq) {
            return (dq->front == -1);
        }
        
        // Function to check if the deque is full
        int isFull(struct Deque* dq) {
            return ((dq->rear + 1) % MAX_SIZE == dq->front);
        }
        
        // Function to insert an element at the front of the deque
        void insertFront(struct Deque* dq, int value) {
            if (isFull(dq)) {
                printf("Deque is full! Cannot insert %d at front\n", value);
                return;
            }
            if (isEmpty(dq)) {
                dq->front = 0;
                dq->rear = 0;
            } else {
                dq->front = (dq->front - 1 + MAX_SIZE) % MAX_SIZE; // Move front back
            }
            dq->items[dq->front] = value;
            printf("%d inserted at the front of the deque\n", value);
        }
        
        // Function to insert an element at the rear of the deque
        void insertRear(struct Deque* dq, int value) {
            if (isFull(dq)) {
                printf("Deque is full! Cannot insert %d at rear\n", value);
                return;
            }
            if (isEmpty(dq)) {
                dq->front = 0;
                dq->rear = 0;
            } else {
                dq->rear = (dq->rear + 1) % MAX_SIZE; // Move rear forward
            }
            dq->items[dq->rear] = value;
            printf("%d inserted at the rear of the deque\n", value);
        }
        
        // Function to delete an element from the front of the deque
        int deleteFront(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot delete from front\n");
                return -1; // Indicate that the deque is empty
            }
        
            int deletedValue = dq->items[dq->front];
            if (dq->front == dq->rear) { // Only one element was present
                dq->front = -1;
                dq->rear = -1;
            } else {
                dq->front = (dq->front + 1) % MAX_SIZE; // Move front forward
            }
        
            printf("%d deleted from the front of the deque\n", deletedValue);
            return deletedValue;
        }
        
        // Function to delete an element from the rear of the deque
        int deleteRear(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot delete from rear\n");
                return -1; // Indicate that the deque is empty
            }
        
            int deletedValue = dq->items[dq->rear];
            if (dq->front == dq->rear) { // Only one element was present
                dq->front = -1;
                dq->rear = -1;
            } else {
                dq->rear = (dq->rear - 1 + MAX_SIZE) % MAX_SIZE; // Move rear back
            }
        
            printf("%d deleted from the rear of the deque\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the deque
        int peekFront(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot peek from front\n");
                return -1; // Indicate that the deque is empty
            }
            return dq->items[dq->front]; // Return the front element
        }
        
        // Function to peek at the rear element of the deque
        int peekRear(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot peek from rear\n");
                return -1; // Indicate that the deque is empty
            }
            return dq->items[dq->rear]; // Return the rear element
        }
        
        // Function to display the deque
        void display(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty!\n");
                return;
            }
            printf("Deque elements: ");
            int i = dq->front;
            while (1) {
                printf("%d ", dq->items[i]);
                if (i == dq->rear) break; // Stop when we reach the rear
                i = (i + 1) % MAX_SIZE; // Move to next element
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct Deque* dq = createDeque();
            
            int choice, value;
        
            do {
                printf("\nDouble-Ended Queue Operations:\n");
                printf("1. Insert at Front\n");
                printf("2. Insert at Rear\n");
                printf("3. Delete from Front\n");
                printf("4. Delete from Rear\n");
                printf("5. Peek Front\n");
                printf("6. Peek Rear\n");
                printf("7. Display\n");
                printf("8. Check if Empty\n");
                printf("9. Check if Full\n");
                printf("10. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter value to insert at front: ");
                        scanf("%d", &value);
                        insertFront(dq, value);
                        break;
                    case 2:
                        printf("Enter value to insert at rear: ");
                        scanf("%d", &value);
                        insertRear(dq, value);
                        break;
                    case 3:
                        deleteFront(dq);
                        break;
                    case 4:
                        deleteRear(dq);
                        break;
                    case 5:
                        value = peekFront(dq);
                        if (value != -1) {
                            printf("Front element is: %d\n", value);
                        }
                        break;
                    case 6:
                        value = peekRear(dq);
                        if (value != -1) {
                            printf("Rear element is: %d\n", value);
                        }
                        break;
                    case 7:
                        display(dq);
                        break;
                    case 8:
                        if (isEmpty(dq)) {
                            printf("Deque is empty\n");
                        } else {
                            printf("Deque is not empty\n");
                        }
                        break;
                    case 9:
                        if (isFull(dq)) {
                            printf("Deque is full\n");
                        } else {
                            printf("Deque is not full\n");
                        }
                        break;
                    case 10:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 10);
        
            free(dq); // Free the allocated memory for the deque
            return 0;
        }
        

    <b id="b">Output:</b>
    Double-Ended Queue Operations:
    1. Insert at Front
    2. Insert at Rear
    3. Delete from Front
    4. Delete from Rear
    5. Peek Front
    6. Peek Rear
    7. Display
    8. Check if Empty
    9. Check if Full
    10. Exit
    Enter your choice: 1
    Enter value to insert at front: 10
    10 inserted at the front of the deque
    
    Double-Ended Queue Operations:
    1. Insert at Front
    2. Insert at Rear
    3. Delete from Front
    4. Delete from Rear
    5. Peek Front
    6. Peek Rear
    7. Display
    8. Check if Empty
    9. Check if Full
    10. Exit
    Enter your choice: 2
    Enter value to insert at rear: 20
    20 inserted at the rear of the deque
    
    Double-Ended Queue Operations:
    1. Insert at Front
    2. Insert at Rear
    3. Delete from Front
    4. Delete from Rear
    5. Peek Front
    6. Peek Rear
    7. Display
    8. Check if Empty
    9. Check if Full
    10. Exit
    Enter your choice: 7
    Deque elements: 10 20     
        </pre>
    </div>

    <div class="d" id="d10">
        <h2>10. IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_SIZE 5 // Define the maximum size of the deque
        #define STRING_LENGTH 100 // Define the maximum length for each string
        
        // Define the structure for the Deque
        struct Deque {
            char items[MAX_SIZE][STRING_LENGTH]; // Array to store strings
            int front;
            int rear;
        };
        
        // Function to create and initialize the deque
        struct Deque* createDeque() {
            struct Deque* dq = (struct Deque*)malloc(sizeof(struct Deque));
            dq->front = -1;
            dq->rear = -1;
            return dq;
        }
        
        // Function to check if the deque is empty
        int isEmpty(struct Deque* dq) {
            return (dq->front == -1);
        }
        
        // Function to check if the deque is full
        int isFull(struct Deque* dq) {
            return ((dq->rear + 1) % MAX_SIZE == dq->front);
        }
        
        // Function to insert an element at the front of the deque
        void insertFront(struct Deque* dq, char* value) {
            if (isFull(dq)) {
                printf("Deque is full! Cannot insert '%s' at front\n", value);
                return;
            }
            if (isEmpty(dq)) {
                dq->front = 0;
                dq->rear = 0;
            } else {
                dq->front = (dq->front - 1 + MAX_SIZE) % MAX_SIZE; // Move front back
            }
            strcpy(dq->items[dq->front], value);
            printf("'%s' inserted at the front of the deque\n", value);
        }
        
        // Function to insert an element at the rear of the deque
        void insertRear(struct Deque* dq, char* value) {
            if (isFull(dq)) {
                printf("Deque is full! Cannot insert '%s' at rear\n", value);
                return;
            }
            if (isEmpty(dq)) {
                dq->front = 0;
                dq->rear = 0;
            } else {
                dq->rear = (dq->rear + 1) % MAX_SIZE; // Move rear forward
            }
            strcpy(dq->items[dq->rear], value);
            printf("'%s' inserted at the rear of the deque\n", value);
        }
        
        // Function to delete an element from the front of the deque
        char* deleteFront(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot delete from front\n");
                return NULL; // Indicate that the deque is empty
            }
        
            char* deletedValue = dq->items[dq->front];
            if (dq->front == dq->rear) { // Only one element was present
                dq->front = -1;
                dq->rear = -1;
            } else {
                dq->front = (dq->front + 1) % MAX_SIZE; // Move front forward
            }
        
            printf("'%s' deleted from the front of the deque\n", deletedValue);
            return deletedValue;
        }
        
        // Function to delete an element from the rear of the deque
        char* deleteRear(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot delete from rear\n");
                return NULL; // Indicate that the deque is empty
            }
        
            char* deletedValue = dq->items[dq->rear];
            if (dq->front == dq->rear) { // Only one element was present
                dq->front = -1;
                dq->rear = -1;
            } else {
                dq->rear = (dq->rear - 1 + MAX_SIZE) % MAX_SIZE; // Move rear back
            }
        
            printf("'%s' deleted from the rear of the deque\n", deletedValue);
            return deletedValue;
        }
        
        // Function to peek at the front element of the deque
        char* peekFront(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot peek from front\n");
                return NULL; // Indicate that the deque is empty
            }
            return dq->items[dq->front]; // Return the front element
        }
        
        // Function to peek at the rear element of the deque
        char* peekRear(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty! Cannot peek from rear\n");
                return NULL; // Indicate that the deque is empty
            }
            return dq->items[dq->rear]; // Return the rear element
        }
        
        // Function to display the deque
        void display(struct Deque* dq) {
            if (isEmpty(dq)) {
                printf("Deque is empty!\n");
                return;
            }
            printf("Deque elements: ");
            int i = dq->front;
            while (1) {
                printf("'%s' ", dq->items[i]);
                if (i == dq->rear) break; // Stop when we reach the rear
                i = (i + 1) % MAX_SIZE; // Move to next element
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct Deque* dq = createDeque();
            
            int choice;
            char value[STRING_LENGTH];
        
            do {
                printf("\nDouble-Ended Queue Operations:\n");
                printf("1. Insert at Front\n");
                printf("2. Insert at Rear\n");
                printf("3. Delete from Front\n");
                printf("4. Delete from Rear\n");
                printf("5. Peek Front\n");
                printf("6. Peek Rear\n");
                printf("7. Display\n");
                printf("8. Check if Empty\n");
                printf("9. Check if Full\n");
                printf("10. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar(); // Consume the newline character
        
                switch (choice) {
                    case 1:
                        printf("Enter string to insert at front: ");
                        fgets(value, STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = 0; // Remove newline character
                        insertFront(dq, value);
                        break;
                    case 2:
                        printf("Enter string to insert at rear: ");
                        fgets(value, STRING_LENGTH, stdin);
                        value[strcspn(value, "\n")] = 0; // Remove newline character
                        insertRear(dq, value);
                        break;
                    case 3:
                        deleteFront(dq);
                        break;
                    case 4:
                        deleteRear(dq);
                        break;
                    case 5:
                        {
                            char* peekedValue = peekFront(dq);
                            if (peekedValue != NULL) {
                                printf("Front element is: '%s'\n", peekedValue);
                            }
                        }
                        break;
                    case 6:
                        {
                            char* peekedValue = peekRear(dq);
                            if (peekedValue != NULL) {
                                printf("Rear element is: '%s'\n", peekedValue);
                            }
                        }
                        break;
                    case 7:
                        display(dq);
                        break;
                    case 8:
                        if (isEmpty(dq)) {
                            printf("Deque is empty\n");
                        } else {
                            printf("Deque is not empty\n");
                        }
                        break;
                    case 9:
                        if (isFull(dq)) {
                            printf("Deque is full\n");
                        } else {
                            printf("Deque is not full\n");
                        }
                        break;
                    case 10:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 10);
        
            free(dq); // Free the allocated memory for the deque
            return 0;
        }
        

    <b id="b">Output:</b>
    Double-Ended Queue Operations:
    1. Insert at Front
    2. Insert at Rear
    3. Delete from Front
    4. Delete from Rear
    5. Peek Front
    6. Peek Rear
    7. Display
    8. Check if Empty
    9. Check if Full
    10. Exit
    Enter your choice: 1
    Enter string to insert at front:
    
     Hello
    'Hello' inserted at the front of the deque
    
    Enter your choice: 2
    Enter string to insert at rear: World
    'World' inserted at the rear of the deque
    
    Enter your choice: 7
    Deque elements: 'Hello' 'World'    
        </pre>
    </div>


    <div class="d" id="d11">
        <h2>11. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        struct Node {
            int data; // The value of the node
            int priority; // The priority of the node
            struct Node* next; // Pointer to the next node
        };
        
        // Function to create a new node
        struct Node* createNode(int data, int priority) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = data;
            newNode->priority = priority;
            newNode->next = NULL;
            return newNode;
        }
        
        // Structure for the priority queue
        struct PriorityQueue {
            struct Node* head; // Head of the linked list
        };
        
        // Function to create a priority queue
        struct PriorityQueue* createPriorityQueue() {
            struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
            pq->head = NULL;
            return pq;
        }
        
        // Function to check if the priority queue is empty
        int isEmpty(struct PriorityQueue* pq) {
            return pq->head == NULL;
        }
        
        // Function to insert an element into the priority queue
        void insert(struct PriorityQueue* pq, int data, int priority) {
            struct Node* newNode = createNode(data, priority);
            if (pq->head == NULL || pq->head->priority < priority) {
                // Insert at the head if the queue is empty or new node has higher priority
                newNode->next = pq->head;
                pq->head = newNode;
            } else {
                // Find the position to insert the new node
                struct Node* current = pq->head;
                while (current->next != NULL && current->next->priority >= priority) {
                    current = current->next;
                }
                newNode->next = current->next;
                current->next = newNode;
            }
            printf("Inserted %d with priority %d\n", data, priority);
        }
        
        // Function to delete the highest priority element
        int deleteHighestPriority(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority queue is empty! Cannot delete.\n");
                return -1; // Indicate that the queue is empty
            }
            struct Node* temp = pq->head;
            int deletedData = temp->data;
            pq->head = pq->head->next; // Move head to next node
            free(temp); // Free the old head
            printf("Deleted %d from the priority queue\n", deletedData);
            return deletedData;
        }
        
        // Function to peek at the highest priority element
        int peekHighestPriority(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority queue is empty! Cannot peek.\n");
                return -1; // Indicate that the queue is empty
            }
            return pq->head->data; // Return the data at the head
        }
        
        // Function to display the priority queue
        void display(struct PriorityQueue* pq) {
            if (isEmpty(pq)) {
                printf("Priority queue is empty!\n");
                return;
            }
            struct Node* current = pq->head;
            printf("Priority Queue: ");
            while (current != NULL) {
                printf("%d (priority: %d) ", current->data, current->priority);
                current = current->next;
            }
            printf("\n");
        }
        
        // Main function
        int main() {
            struct PriorityQueue* pq = createPriorityQueue();
            
            int choice, data, priority;
        
            do {
                printf("\nPriority Queue Operations:\n");
                printf("1. Insert\n");
                printf("2. Delete Highest Priority\n");
                printf("3. Peek Highest Priority\n");
                printf("4. Display\n");
                printf("5. Check if Empty\n");
                printf("6. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter integer to insert: ");
                        scanf("%d", &data);
                        printf("Enter priority (higher number = higher priority): ");
                        scanf("%d", &priority);
                        insert(pq, data, priority);
                        break;
                    case 2:
                        deleteHighestPriority(pq);
                        break;
                    case 3:
                        {
                            int peekedValue = peekHighestPriority(pq);
                            if (peekedValue != -1) {
                                printf("Highest priority element is: %d\n", peekedValue);
                            }
                        }
                        break;
                    case 4:
                        display(pq);
                        break;
                    case 5:
                        if (isEmpty(pq)) {
                            printf("Priority queue is empty\n");
                        } else {
                            printf("Priority queue is not empty\n");
                        }
                        break;
                    case 6:
                        printf("Exiting...\n");
                        break;
                    default:
                        printf("Invalid choice! Please try again.\n");
                }
            } while (choice != 6);
        
            free(pq); // Free the allocated memory for the priority queue
            return 0;
        }
        


    <b id="b">Output:</b>
    Priority Queue Operations:
    1. Insert
    2. Delete Highest Priority
    3. Peek Highest Priority
    4. Display
    5. Check if Empty
    6. Exit
    Enter your choice: 1
    Enter integer to insert: 10
    Enter priority (higher number = higher priority): 2
    Inserted 10 with priority 2
    
    Enter your choice: 1
    Enter integer to insert: 20
    Enter priority (higher number = higher priority): 3
    Inserted 20 with priority 3
    
    Enter your choice: 4
    Priority Queue: 20 (priority: 3) 10 (priority: 2)
    
    Enter your choice: 3
    Highest priority element is: 20
    
    Enter your choice: 2
    Deleted 20 from the priority queue
        
        </pre>
    </div>


    <div class="d" id="d12">
        <h2>12.  IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL).</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_SIZE 100
        
        typedef struct {
            char *data[MAX_SIZE];
            int size;
        } PriorityQueue;
        
        void initQueue(PriorityQueue *pq) {
            pq->size = 0;
        }
        
        int isEmpty(PriorityQueue *pq) {
            return pq->size == 0;
        }
        
        int isFull(PriorityQueue *pq) {
            return pq->size == MAX_SIZE;
        }
        
        void swap(char **a, char **b) {
            char *temp = *a;
            *a = *b;
            *b = temp;
        }
        
        void heapifyUp(PriorityQueue *pq, int index) {
            while (index > 0) {
                int parentIndex = (index - 1) / 2;
                if (strcmp(pq->data[index], pq->data[parentIndex]) > 0) {
                    swap(&pq->data[index], &pq->data[parentIndex]);
                    index = parentIndex;
                } else {
                    break;
                }
            }
        }
        
        void heapifyDown(PriorityQueue *pq, int index) {
            int largest = index;
            int leftChild = 2 * index + 1;
            int rightChild = 2 * index + 2;
        
            if (leftChild < pq->size && strcmp(pq->data[leftChild], pq->data[largest]) > 0) {
                largest = leftChild;
            }
            if (rightChild < pq->size && strcmp(pq->data[rightChild], pq->data[largest]) > 0) {
                largest = rightChild;
            }
            if (largest != index) {
                swap(&pq->data[index], &pq->data[largest]);
                heapifyDown(pq, largest);
            }
        }
        
        void insert(PriorityQueue *pq, const char *item) {
            if (isFull(pq)) {
                printf("Priority Queue is full!\n");
                return;
            }
            pq->data[pq->size] = strdup(item); // Duplicate the string
            pq->size++;
            heapifyUp(pq, pq->size - 1);
        }
        
        char* delete(PriorityQueue *pq) {
            if (isEmpty(pq)) {
                printf("Priority Queue is empty!\n");
                return NULL;
            }
            char *root = pq->data[0];
            pq->data[0] = pq->data[pq->size - 1];
            pq->size--;
            heapifyDown(pq, 0);
            return root;
        }
        
        char* peek(PriorityQueue *pq) {
            if (isEmpty(pq)) {
                return NULL;
            }
            return pq->data[0];
        }
        
        int main() {
            PriorityQueue pq;
            initQueue(&pq);
        
            insert(&pq, "banana");
            insert(&pq, "apple");
            insert(&pq, "cherry");
        
            printf("Peek: %s\n", peek(&pq));  // Outputs: cherry
        
            char *deleted = delete(&pq);
            printf("Deleted: %s\n", deleted);  // Outputs: cherry
            free(deleted); // Free the deleted string
        
            printf("Peek after deletion: %s\n", peek(&pq));  // Outputs: banana
        
            // Clean up remaining items
            while (!isEmpty(&pq)) {
                deleted = delete(&pq);
                printf("Deleted: %s\n", deleted);
                free(deleted); // Free the deleted string
            }
        
            return 0;
        }
        

    <b id="b">Output:</b>
    Peek: cherry
    Deleted: cherry
    Peek after deletion: banana
    Deleted: banana
    Deleted: apple
        
        </pre>
    </div>


    <div class="d" id="d13">
        <h2>13. Find the first circular tour that visits all petrol pumps.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>

        int findStartPump(int petrol[], int distance[], int n) {
            int total_petrol = 0, total_distance = 0;
            int current_petrol = 0, start_index = 0;
        
            for (int i = 0; i < n; i++) {
                total_petrol += petrol[i];
                total_distance += distance[i];
                current_petrol += petrol[i] - distance[i];
        
                // If current petrol is negative, reset start index
                if (current_petrol < 0) {
                    start_index = i + 1;
                    current_petrol = 0; // Reset current petrol
                }
            }
        
            // If total petrol is greater than total distance, return the start index
            return (total_petrol >= total_distance) ? start_index : -1;
        }
        
        int main() {
            int petrol[] = {4, 6, 7, 4};
            int distance[] = {6, 5, 3, 5};
            int n = sizeof(petrol) / sizeof(petrol[0]);
        
            int start = findStartPump(petrol, distance, n);
            if (start != -1) {
                printf("The first circular tour can start at petrol pump index: %d\n", start);
            } else {
                printf("There is no circular tour possible.\n");
            }
        
            return 0;
        }
        
     

    <b id="b">Output:</b>
    The first circular tour can start at petrol pump index: 1

        </pre>
    </div>


    <div class="d" id="d14">
        <h2>14. Length of the longest valid substring.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        int longestValidParentheses(char *s) {
            int max_length = 0;
            int *stack = (int *)malloc(sizeof(int) * (strlen(s) + 1));
            int top = -1; // Stack pointer
            stack[++top] = -1; // Initialize with -1
        
            for (int i = 0; s[i] != '\0'; i++) {
                if (s[i] == '(') {
                    stack[++top] = i; // Push index of '('
                } else {
                    // Pop the last index
                    if (top != -1) {
                        top--; // Pop the last index
        
                        // If stack is empty, push current index
                        if (top == -1) {
                            stack[++top] = i; // Push current index
                        } else {
                            // Calculate valid length
                            int length = i - stack[top];
                            if (length > max_length) {
                                max_length = length;
                            }
                        }
                    }
                }
            }
        
            free(stack);
            return max_length;
        }
        
        int main() {
            char s[] = "(()())";
            int length = longestValidParentheses(s);
            printf("The length of the longest valid parentheses substring is: %d\n", length);
            return 0;
        }
        

    <b id="b">Output:</b>
    The length of the longest valid parentheses substring is: 6

        </pre>
    </div>
    
    <div class="d" id="d15">
        <h2>15. Find the Next Greater Element.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        void nextGreaterElement(int *arr, int n) {
            int *result = (int *)malloc(n * sizeof(int));
            int *stack = (int *)malloc(n * sizeof(int));
            int top = -1; // Stack pointer
        
            // Initialize result array
            for (int i = 0; i < n; i++) {
                result[i] = -1; // Default value
            }
        
            // Iterate through the array
            for (int i = 0; i < n; i++) {
                // While stack is not empty and current element is greater than the element
                // at the index stored in the stack
                while (top != -1 && arr[i] > arr[stack[top]]) {
                    result[stack[top]] = arr[i]; // Set NGE
                    top--; // Pop from the stack
                }
                // Push the current index onto the stack
                stack[++top] = i;
            }
        
            // Output results
            printf("Next Greater Element for each element: \n");
            for (int i = 0; i < n; i++) {
                printf("%d -> %d\n", arr[i], result[i]);
            }
        
            free(result);
            free(stack);
        }
        
        int main() {
            int arr[] = {4, 5, 2, 10, 8};
            int n = sizeof(arr) / sizeof(arr[0]);
            nextGreaterElement(arr, n);
            return 0;
        }
        

    <b id="b">Output:</b>
    Next Greater Element for each element: 
    4 -> 5
    5 -> 10
    2 -> 10
    10 -> -1
    8 -> -1
    
        </pre>
    </div>

    <div class="d" id="d16">
        <h2>16. Find Next Smaller Element.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        void nextSmallerElement(int *arr, int n) {
            int *result = (int *)malloc(n * sizeof(int));
            int *stack = (int *)malloc(n * sizeof(int));
            int top = -1; // Stack pointer
        
            // Initialize result array
            for (int i = 0; i < n; i++) {
                result[i] = -1; // Default value
            }
        
            // Iterate through the array
            for (int i = 0; i < n; i++) {
                // While stack is not empty and current element is smaller than the element
                // at the index stored in the stack
                while (top != -1 && arr[i] < arr[stack[top]]) {
                    result[stack[top]] = arr[i]; // Set NSE
                    top--; // Pop from the stack
                }
                // Push the current index onto the stack
                stack[++top] = i;
            }
        
            // Output results
            printf("Next Smaller Element for each element: \n");
            for (int i = 0; i < n; i++) {
                printf("%d -> %d\n", arr[i], result[i]);
            }
        
            free(result);
            free(stack);
        }
        
        int main() {
            int arr[] = {4, 5, 2, 10, 8};
            int n = sizeof(arr) / sizeof(arr[0]);
            nextSmallerElement(arr, n);
            return 0;
        }
        
            

    <b id="b">Output:</b>
    Next Smaller Element for each element: 
    4 -> 2
    5 -> 2
    2 -> -1
    10 -> 8
    8 -> -1
        
        </pre>
    </div>

    <div class="d" id="d17">
        <h2>17. Queue based approach for first non-repeating character in a stream.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        #include < string.h>
        
        #define MAX_CHAR 256
        
        typedef struct Node {
            char data;
            struct Node *next;
        } Node;
        
        typedef struct Queue {
            Node *front;
            Node *rear;
        } Queue;
        
        Queue* createQueue() {
            Queue *q = (Queue *)malloc(sizeof(Queue));
            q->front = q->rear = NULL;
            return q;
        }
        
        void enqueue(Queue *q, char c) {
            Node *temp = (Node *)malloc(sizeof(Node));
            temp->data = c;
            temp->next = NULL;
            if (q->rear == NULL) {
                q->front = q->rear = temp;
                return;
            }
            q->rear->next = temp;
            q->rear = temp;
        }
        
        void dequeue(Queue *q) {
            if (q->front == NULL) return;
            Node *temp = q->front;
            q->front = q->front->next;
            if (q->front == NULL) q->rear = NULL;
            free(temp);
        }
        
        char front(Queue *q) {
            if (q->front != NULL) {
                return q->front->data;
            }
            return '\0'; // Return null character if queue is empty
        }
        
        void firstNonRepeatingCharacter(char *stream) {
            int charCount[MAX_CHAR] = {0}; // Character count
            Queue *q = createQueue();
        
            for (int i = 0; stream[i] != '\0'; i++) {
                char currentChar = stream[i];
        
                // Update count of the character
                charCount[currentChar]++;
        
                // If it's the first occurrence, add to the queue
                if (charCount[currentChar] == 1) {
                    enqueue(q, currentChar);
                } 
                // If it's the second occurrence, remove from the queue
                else if (charCount[currentChar] == 2) {
                    // Dequeue until the front of the queue is non-repeating
                    while (q->front != NULL && charCount[q->front->data] > 1) {
                        dequeue(q);
                    }
                }
        
                // Print the current first non-repeating character
                char firstNonRepeating = front(q);
                if (firstNonRepeating != '\0') {
                    printf("First non-repeating character so far: %c\n", firstNonRepeating);
                } else {
                    printf("No non-repeating character so far.\n");
                }
            }
        
            // Clean up
            while (q->front != NULL) {
                dequeue(q);
            }
            free(q);
        }
        
        int main() {
            char stream[] = "geeksforgeeks";
            firstNonRepeatingCharacter(stream);
            return 0;
        }
        
        

    <b id="b">Output:</b>
    First non-repeating character so far: g
    First non-repeating character so far: g
    First non-repeating character so far: e
    First non-repeating character so far: e
    First non-repeating character so far: e
    First non-repeating character so far: f
    First non-repeating character so far: f
    First non-repeating character so far: r
    First non-repeating character so far: r
    First non-repeating character so far: t
    First non-repeating character so far: t
    First non-repeating character so far: k
    First non-repeating character so far: k
    First non-repeating character so far: s
        
        </pre>
    </div>

    <div class="d" id="d18">
        <h2>18. Reverse First K elements of Queue.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        typedef struct Node {
            int data;
            struct Node *next;
        } Node;
        
        typedef struct Queue {
            Node *front;
            Node *rear;
        } Queue;
        
        // Function to create a new queue node
        Node* newNode(int value) {
            Node* temp = (Node*)malloc(sizeof(Node));
            temp->data = value;
            temp->next = NULL;
            return temp;
        }
        
        // Function to create a queue
        Queue* createQueue() {
            Queue* q = (Queue*)malloc(sizeof(Queue));
            q->front = q->rear = NULL;
            return q;
        }
        
        // Function to enqueue an element
        void enqueue(Queue* q, int value) {
            Node* temp = newNode(value);
            if (q->rear == NULL) {
                q->front = q->rear = temp;
                return;
            }
            q->rear->next = temp;
            q->rear = temp;
        }
        
        // Function to dequeue an element
        int dequeue(Queue* q) {
            if (q->front == NULL) return -1; // Queue is empty
            Node* temp = q->front;
            int value = temp->data;
            q->front = q->front->next;
            if (q->front == NULL) q->rear = NULL; // Queue is now empty
            free(temp);
            return value;
        }
        
        // Function to reverse the first K elements of the queue
        void reverseFirstKElements(Queue* q, int k) {
            if (k <= 0 || q->front == NULL) return; // No elements to reverse
        
            Node* stack[k]; // Using an array as stack to hold K elements
            int count = 0;
        
            // Dequeue the first K elements and push them onto the stack
            while (count < k && q->front != NULL) {
                stack[count++] = newNode(dequeue(q));
            }
        
            // Pop elements from the stack and enqueue them back to the queue
            for (int i = count - 1; i >= 0; i--) {
                enqueue(q, stack[i]->data);
                free(stack[i]); // Free the temporary nodes
            }
        
            // Move the remaining elements to the back of the queue
            for (int i = 0; i < (k - count); i++) {
                int temp = dequeue(q);
                if (temp != -1) {
                    enqueue(q, temp);
                }
            }
        }
        
        // Function to print the queue
        void printQueue(Queue* q) {
            Node* temp = q->front;
            while (temp != NULL) {
                printf("%d ", temp->data);
                temp = temp->next;
            }
            printf("\n");
        }
        
        int main() {
            Queue* q = createQueue();
            enqueue(q, 1);
            enqueue(q, 2);
            enqueue(q, 3);
            enqueue(q, 4);
            enqueue(q, 5);
        
            printf("Original queue: ");
            printQueue(q);
        
            int k = 3;
            reverseFirstKElements(q, k);
        
            printf("Queue after reversing first %d elements: ", k);
            printQueue(q);
        
            // Clean up
            while (q->front != NULL) {
                dequeue(q);
            }
            free(q);
            return 0;
        }
        


    <b id="b">Output:</b>
    Original queue: 1 2 3 4 5 
    Queue after reversing first 3 elements: 3 2 1 4 5 
        
        </pre>
    </div>

    <div class="d" id="d19">
        <h2>19. Queue Reversal.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        // Node structure for the queue
        typedef struct Node {
            int data;
            struct Node* next;
        } Node;
        
        // Queue structure
        typedef struct Queue {
            Node* front;
            Node* rear;
        } Queue;
        
        // Function to create a new queue node
        Node* newNode(int value) {
            Node* temp = (Node*)malloc(sizeof(Node));
            temp->data = value;
            temp->next = NULL;
            return temp;
        }
        
        // Function to create a queue
        Queue* createQueue() {
            Queue* q = (Queue*)malloc(sizeof(Queue));
            q->front = q->rear = NULL;
            return q;
        }
        
        // Function to enqueue an element
        void enqueue(Queue* q, int value) {
            Node* temp = newNode(value);
            if (q->rear == NULL) {
                q->front = q->rear = temp;
                return;
            }
            q->rear->next = temp;
            q->rear = temp;
        }
        
        // Function to dequeue an element
        int dequeue(Queue* q) {
            if (q->front == NULL) return -1; // Queue is empty
            Node* temp = q->front;
            int value = temp->data;
            q->front = q->front->next;
            if (q->front == NULL) q->rear = NULL; // Queue is now empty
            free(temp);
            return value;
        }
        
        // Recursive function to reverse the queue
        void reverseQueue(Queue* q) {
            // Base case: If the queue is empty, return
            if (q->front == NULL) return;
        
            // Dequeue the front element
            int value = dequeue(q);
        
            // Reverse the remaining queue
            reverseQueue(q);
        
            // Enqueue the front element back
            enqueue(q, value);
        }
        
        // Function to print the queue
        void printQueue(Queue* q) {
            Node* temp = q->front;
            while (temp != NULL) {
                printf("%d ", temp->data);
                temp = temp->next;
            }
            printf("\n");
        }
        
        int main() {
            Queue* q = createQueue();
            enqueue(q, 1);
            enqueue(q, 2);
            enqueue(q, 3);
            enqueue(q, 4);
            enqueue(q, 5);
        
            printf("Original queue: ");
            printQueue(q);
        
            reverseQueue(q);
        
            printf("Reversed queue: ");
            printQueue(q);
        
            // Clean up
            while (q->front != NULL) {
                dequeue(q);
            }
            free(q);
            return 0;
        }
        

    <b id="b">Output:</b>
    Original queue: 1 2 3 4 5 
    Reversed queue: 5 4 3 2 1 
        
        </pre>
    </div>

    <div class="d" id="d20">
        <h2>20. Rotten Oranges.</h2><br>
        <pre>
    <b id="b">Code:</b>
    #include < stdio.h>
        #include < stdlib.h>
        
        #define MAX 1000
        
        typedef struct {
            int x, y;
        } Point;
        
        int orangesRotting(int grid[MAX][MAX], int rows, int cols) {
            int freshCount = 0;
            int minutes = 0;
            Point queue[MAX * MAX]; // Queue to hold rotten orange coordinates
            int front = 0, rear = 0;
        
            // Initialize queue with all rotten oranges
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    if (grid[i][j] == 2) {
                        queue[rear++] = (Point){i, j}; // Add rotten orange to queue
                    } else if (grid[i][j] == 1) {
                        freshCount++; // Count fresh oranges
                    }
                }
            }
        
            // Directions for the 4 adjacent cells
            int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        
            // BFS to spread rot
            while (front < rear) {
                int size = rear - front; // Number of rotten oranges in this level
                for (int i = 0; i < size; i++) {
                    Point current = queue[front++];
                    for (int j = 0; j < 4; j++) {
                        int newX = current.x + directions[j][0];
                        int newY = current.y + directions[j][1];
                        // Check bounds and if the neighbor is a fresh orange
                        if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1)
                        {
                            grid[newX][newY] = 2; // Mark as rotten
                            freshCount--; // Decrease fresh orange count
                            queue[rear++] = (Point){newX, newY}; // Enqueue new rotten orange
                        }
                    }
                }
                if (front < rear) { // Increment minutes only if we processed new oranges
                    minutes++;
                }
            }
        
            // If there are still fresh oranges left, return -1
            return freshCount == 0 ? minutes : -1;
        }
        
        int main() {
            int grid[MAX][MAX] = {
                {2, 1, 1},
                {1, 1, 0},
                {0, 1, 2}
            };
            int rows = 3, cols = 3;
        
            int result = orangesRotting(grid, rows, cols);
            if (result != -1) {
                printf("All fresh oranges rot in %d minute(s).\n", result);
            } else {
                printf("Some fresh oranges cannot rot.\n");
            }
        
            return 0;
        }
        
      

    <b id="b">Output:</b>
    2 1 1
    1 1 0
    0 1 2

    All fresh oranges rot in 4 minute(s).
    
        </pre>
    </div>

   
</body>
</html>